{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"This GitHub repository is dedicated to explain the fundamentals of game development to absolute beginners, with no prior experience required. The game engine we are using is Unity, but the concepts them selves are compatible across any game engines. Installation Unity package installation Interactive documentation Theory Game Engines Physics Time Rendering World building World Barriers Terrain Biomes Landmarks Blocking Tools Level design Building blocks Camera Character controller Console Triggers Teleports Timers Spawners Counters Quests Inventory Map Chance Programming Programming vs Cooking Most basic programming topics: Constants Variables Types Scope Functions Operators Conditions Loops Work in progress :)","title":"Home"},{"location":"index.html#installation","text":"Unity package installation Interactive documentation","title":"Installation"},{"location":"index.html#theory","text":"Game Engines Physics Time Rendering","title":"Theory"},{"location":"index.html#world-building","text":"World Barriers Terrain Biomes Landmarks Blocking Tools Level design","title":"World building"},{"location":"index.html#building-blocks","text":"Camera Character controller Console Triggers Teleports Timers Spawners Counters Quests Inventory Map Chance","title":"Building blocks"},{"location":"index.html#programming","text":"Programming vs Cooking Most basic programming topics: Constants Variables Types Scope Functions Operators Conditions Loops Work in progress :)","title":"Programming"},{"location":"csharp/conditions.html","text":"Conditions Conditions in programming are like following a recipe that adjusts based on what ingredients you have on hand. Imagine you're making a soup. The recipe might say, \"If you have carrots, add two cups; otherwise, add potatoes.\" This conditional instruction changes the course of your cooking based on the availability of ingredients, leading to different variations of the soup. In programming, conditions work similarly through the use of \"if-else\" statements. These statements allow a program to execute different code blocks \"branches\" based on whether a condition is true or false. For example, if a user is over 18 (condition is true), they can view certain content; otherwise (condition is false), they are redirected to a different page. Just as in cooking, where you might adjust the heat based on how quickly something is cooking (\"If the water is boiling too rapidly, lower the heat\"), in programming, you might adjust the flow of a program based on user input, the state of data, or other conditions. This flexibility allows for dynamic responses and customized outcomes, much like how a skilled chef can adapt a recipe to achieve the best possible dish under the given circumstances. We can compare two numbers if one number is great than the other void Start() { int age = 18; // compare if age is greater or equal to 18 if(age >= 18) { Debug.Log(\"You are allright!\"); } else { Debug.Log(\"You have to be older than 18!\"); } // is the same as writing // compare if age is less than 18 if(age < 18) { Debug.Log(\"You have to be older than 18!\"); } else { Debug.Log(\"You are allright!\"); } } We can also compare specific words using equality operator == void Start() { string name = \"john\"; // does the name match john? if(name == \"john\") { Debug.Log(\"We found John!\"); } else { Debug.Log(\"This is not the person we are looking for!\"); } // Not comparison! but variable assignment! // One of the most common mistake programmers make. if(name = \"john) { Debug.Log(\"We found John!\"); } else { Debug.Log(\"This is not the person we are looking for!\"); } } If we need to match multiple words we can write it as this void Start() { string name = \"john\"; // does the name match john? if(name == \"john\") { Debug.Log(\"We found John!\"); } else if(name == \"jack\") { Debug.Log(\"We found Jack!\"); } else if(name == \"perry\") { Debug.Log(\"We found Perry!\"); } else { Debug.Log(\"This is not the person we are looking for!\"); } } If our conditions branch in many different options we can use switch instead void Start() { string name = \"john\"; // pass the value to switch switch(name) { // when we match the value case \"john\": Debug.Log(\"We found John!\"); break; case \"jack\": Debug.Log(\"We found Jack!\"); break; case \"perry\": Debug.Log(\"We found Perry!\"); break; // when we do not match any value default: Debug.Log(\"This is not the person we are looking for!\"); break; } } Continue with loops Conditions on Microsoft.com","title":"Conditions"},{"location":"csharp/conditions.html#conditions","text":"Conditions in programming are like following a recipe that adjusts based on what ingredients you have on hand. Imagine you're making a soup. The recipe might say, \"If you have carrots, add two cups; otherwise, add potatoes.\" This conditional instruction changes the course of your cooking based on the availability of ingredients, leading to different variations of the soup. In programming, conditions work similarly through the use of \"if-else\" statements. These statements allow a program to execute different code blocks \"branches\" based on whether a condition is true or false. For example, if a user is over 18 (condition is true), they can view certain content; otherwise (condition is false), they are redirected to a different page. Just as in cooking, where you might adjust the heat based on how quickly something is cooking (\"If the water is boiling too rapidly, lower the heat\"), in programming, you might adjust the flow of a program based on user input, the state of data, or other conditions. This flexibility allows for dynamic responses and customized outcomes, much like how a skilled chef can adapt a recipe to achieve the best possible dish under the given circumstances. We can compare two numbers if one number is great than the other void Start() { int age = 18; // compare if age is greater or equal to 18 if(age >= 18) { Debug.Log(\"You are allright!\"); } else { Debug.Log(\"You have to be older than 18!\"); } // is the same as writing // compare if age is less than 18 if(age < 18) { Debug.Log(\"You have to be older than 18!\"); } else { Debug.Log(\"You are allright!\"); } } We can also compare specific words using equality operator == void Start() { string name = \"john\"; // does the name match john? if(name == \"john\") { Debug.Log(\"We found John!\"); } else { Debug.Log(\"This is not the person we are looking for!\"); } // Not comparison! but variable assignment! // One of the most common mistake programmers make. if(name = \"john) { Debug.Log(\"We found John!\"); } else { Debug.Log(\"This is not the person we are looking for!\"); } } If we need to match multiple words we can write it as this void Start() { string name = \"john\"; // does the name match john? if(name == \"john\") { Debug.Log(\"We found John!\"); } else if(name == \"jack\") { Debug.Log(\"We found Jack!\"); } else if(name == \"perry\") { Debug.Log(\"We found Perry!\"); } else { Debug.Log(\"This is not the person we are looking for!\"); } } If our conditions branch in many different options we can use switch instead void Start() { string name = \"john\"; // pass the value to switch switch(name) { // when we match the value case \"john\": Debug.Log(\"We found John!\"); break; case \"jack\": Debug.Log(\"We found Jack!\"); break; case \"perry\": Debug.Log(\"We found Perry!\"); break; // when we do not match any value default: Debug.Log(\"This is not the person we are looking for!\"); break; } } Continue with loops Conditions on Microsoft.com","title":"Conditions"},{"location":"csharp/constants.html","text":"Constants Drawing the parallel between programming concepts and cooking further, let's explore the idea of constants. In the culinary world, constants can be likened to the essential, unchanging elements of a recipe. Consider salt: its role and taste remain consistent across dishes. Whether you're baking a cake or seasoning a stew, the salt's fundamental properties\u2014its flavor and its chemical composition\u2014do not vary. It serves as a constant, providing a reliable foundation upon which the complexity of a dish can be built. In programming, constants hold a similar place of importance. They are the unalterable values that a program relies on throughout its execution. Just as a pinch of salt consistently adds the same flavor enhancement to a variety of dishes, a constant in a program provides a steady, immutable reference point. Whether it's the maximum size of a data structure, the URL of a web service, or a literal value used for comparison, constants ensure that certain critical values remain unchanged, no matter what operations or functions the program performs. This immutability makes constants a crucial tool in maintaining the integrity and predictability of a program's behavior, akin to how staple ingredients like salt help anchor and define the flavor profile of a dish. 5; // is a whole number 5.5f; // is a floating point number 5.5; // is a double precision floating point number true; // is positive boolean value 's' // is a single character \"this is a plain text\"; // is a string While constants might be assigned to a variable they appear on the right side from the = equal symbol. int fiveInt = 5; float fiveFloat = 5.5f; double fiveDouble = 5.5; bool boolean = true; char plainChar = 's'; string plainString = \"this is a plain text\"; They can also appear directly as a parameter of a function. void Start() { MyFunctionTakesInt(5); MyFunctionTakesFloat(5.5f); MyFunctionTakesDouble(5.5); MyFunctionTakesBool(true); MyFunctionTakesChar('s'); MyFunctionTakesString(\"this is a plain text\"); } Continue with variables Constants on Microsoft.com","title":"Constants"},{"location":"csharp/constants.html#constants","text":"Drawing the parallel between programming concepts and cooking further, let's explore the idea of constants. In the culinary world, constants can be likened to the essential, unchanging elements of a recipe. Consider salt: its role and taste remain consistent across dishes. Whether you're baking a cake or seasoning a stew, the salt's fundamental properties\u2014its flavor and its chemical composition\u2014do not vary. It serves as a constant, providing a reliable foundation upon which the complexity of a dish can be built. In programming, constants hold a similar place of importance. They are the unalterable values that a program relies on throughout its execution. Just as a pinch of salt consistently adds the same flavor enhancement to a variety of dishes, a constant in a program provides a steady, immutable reference point. Whether it's the maximum size of a data structure, the URL of a web service, or a literal value used for comparison, constants ensure that certain critical values remain unchanged, no matter what operations or functions the program performs. This immutability makes constants a crucial tool in maintaining the integrity and predictability of a program's behavior, akin to how staple ingredients like salt help anchor and define the flavor profile of a dish. 5; // is a whole number 5.5f; // is a floating point number 5.5; // is a double precision floating point number true; // is positive boolean value 's' // is a single character \"this is a plain text\"; // is a string While constants might be assigned to a variable they appear on the right side from the = equal symbol. int fiveInt = 5; float fiveFloat = 5.5f; double fiveDouble = 5.5; bool boolean = true; char plainChar = 's'; string plainString = \"this is a plain text\"; They can also appear directly as a parameter of a function. void Start() { MyFunctionTakesInt(5); MyFunctionTakesFloat(5.5f); MyFunctionTakesDouble(5.5); MyFunctionTakesBool(true); MyFunctionTakesChar('s'); MyFunctionTakesString(\"this is a plain text\"); } Continue with variables Constants on Microsoft.com","title":"Constants"},{"location":"csharp/functions.html","text":"Functions Functions in programming are akin to transformative processes in cooking; they represent a change or a series of changes. Consider the action of slicing tomatoes within a recipe. Here, tomatoes serve as our \"ingredients\"\u2014the data, if you will\u2014and slicing represents the \"function\" that transforms these ingredients. The function of slicing requires inputs: whole tomatoes and the desired size of the slices. The output of this function is the sliced tomatoes, ready for further use in the recipe. This process illustrates how a function takes initial inputs, performs defined operations (in this case, slicing to a specific size), and produces outputs. Similarly, an oven can be thought of as another type of function in our culinary analogy. The inputs for this \"oven function\" include the uncooked food, the cooking time duration, and the set temperature. The output, much like the result of a programming function, is the transformed state of the input: cooked food, ready to be served. This approach to understanding functions emphasizes the concept that actions\u2014or functions\u2014in programming receive inputs, undergo a specific set of operations or transformations, and then yield outputs. This parallels cooking actions, where ingredients are transformed through methods such as slicing or heating, resulting in a new state or product. // takes an int as an input value // outputs an int as an output value int OurFunction(int value) { return 5; } // does not take any input // outputs an int int OurFunction() { return 5; } // does not take any input // does not output any output void OurFunction() { // body of a function } // Previous function would be useles to call. // Lets make it do something. // We can modify for example variables which were defined in parent scope. int myNumber; void OurFunction() { myNumber = 5; } // We can also call another function from a function. void OurOtherFunction() { // which assignes the value of the variable myNumber to number 5 OurFunction(); } // If we call our self from within a function we cause an infinite recursion. // So our game hangs indefinitelly. void OurHangingFunction() { OurHangingFunction(); } Function names 1myFunction \u274c do not start names with a number ko\u010di\u010dka$#. \u274c do not use special symbols my variable \u274c do not use spaces My_Function \u274c do not use underscore instead of space in function names MyFunction \u2705 do start function name with upper case Continue with operators Functions on Microsoft.com","title":"Functions"},{"location":"csharp/functions.html#functions","text":"Functions in programming are akin to transformative processes in cooking; they represent a change or a series of changes. Consider the action of slicing tomatoes within a recipe. Here, tomatoes serve as our \"ingredients\"\u2014the data, if you will\u2014and slicing represents the \"function\" that transforms these ingredients. The function of slicing requires inputs: whole tomatoes and the desired size of the slices. The output of this function is the sliced tomatoes, ready for further use in the recipe. This process illustrates how a function takes initial inputs, performs defined operations (in this case, slicing to a specific size), and produces outputs. Similarly, an oven can be thought of as another type of function in our culinary analogy. The inputs for this \"oven function\" include the uncooked food, the cooking time duration, and the set temperature. The output, much like the result of a programming function, is the transformed state of the input: cooked food, ready to be served. This approach to understanding functions emphasizes the concept that actions\u2014or functions\u2014in programming receive inputs, undergo a specific set of operations or transformations, and then yield outputs. This parallels cooking actions, where ingredients are transformed through methods such as slicing or heating, resulting in a new state or product. // takes an int as an input value // outputs an int as an output value int OurFunction(int value) { return 5; } // does not take any input // outputs an int int OurFunction() { return 5; } // does not take any input // does not output any output void OurFunction() { // body of a function } // Previous function would be useles to call. // Lets make it do something. // We can modify for example variables which were defined in parent scope. int myNumber; void OurFunction() { myNumber = 5; } // We can also call another function from a function. void OurOtherFunction() { // which assignes the value of the variable myNumber to number 5 OurFunction(); } // If we call our self from within a function we cause an infinite recursion. // So our game hangs indefinitelly. void OurHangingFunction() { OurHangingFunction(); } Function names 1myFunction \u274c do not start names with a number ko\u010di\u010dka$#. \u274c do not use special symbols my variable \u274c do not use spaces My_Function \u274c do not use underscore instead of space in function names MyFunction \u2705 do start function name with upper case Continue with operators Functions on Microsoft.com","title":"Functions"},{"location":"csharp/loops.html","text":"Loops In programming, loops facilitate the repetition of instructions. Instead of executing an instruction once and moving on, a loop allows the instruction to repeat itself, typically until a certain condition is met. Consider the process of kneading dough as an analogy. You repeatedly pull and stretch the dough until it reaches the desired consistency. This change in the dough's texture serves as the condition to end the kneading loop. Similarly, imagine pouring milk into a measuring cup. The action of pouring is the repeated instruction. The loop continues until the milk reaches a specific level in the cup, at which point the condition to terminate the loop is met. This process illustrates how loops function in programming, repeating actions efficiently until a defined condition is satisfied. // In math we often represent percents ranging from 0 to 100 // In games we often represent percents as floats ranging from 0 to 1 float doughKneedingProgress = 0.0f; void Start() { // repeat until progress reaches 1.0 while(doughKneedingProgress < 1.0f) { // increase the dough kneeding progress by 1 percent doughKneedingProgress += 0.01f; // output the kneeding progress to console Debug.log($\"Kneeding dough: {doughKneedingProgress * 100}%\"); } // output to console that we are done Debug.log(\"Dough is done!\"); } Imagine a tray filled with cupcakes awaiting frosting. We could design a single function to apply a specific frosting pattern to one cupcake. By executing this function for each cupcake on the tray, effectively repeating the pattern across all cupcakes, we establish a loop. This loop allows us to efficiently apply the same decorative frosting to each cupcake, ensuring consistency and saving time. // tray full of cupcakes CupCake[] cupCakes = new CupCake[10]; void Start() { // make sure to repeat this until we reach all cupcakes for(int i = 0; i < cupCakes.length; i++) { // add frosting over each cupcake CupCakes[i].AddFrosting(); } } We can write the same program slightly simpler, each time we repeat the loop we obtain the correct cupcake. We lost the information about which cupcake we are right now processing which depends on the program we are writing. // tray full of cupcakes CupCake[] cupCakes = new CupCake[10]; void Start() { // make sure to repeat this until we reach all cupcakes foreach(CupCake cupCake in cupCakes) { // add frosting over each cupcake cupCake.AddFrosting(); } } We can also write a loop as a recursive function. This method is rarely used but sometimes it can be handy. // tray full of cupcakes CupCake[] cupCakes = new CupCake[10]; void Start() { AddFrosting(cupCakes, 0); } void AddFrosting(CupCake[] cupCakes, int cupCakeIndex) { if(cupCakeIndex < cupCakes.Length) { cupCakes[cupCakeIndex].AddFrosting(); AddFrosting(cupCakes, cupCakeIndex + 1); } } Loops on Microsoft.com","title":"Loops"},{"location":"csharp/loops.html#loops","text":"In programming, loops facilitate the repetition of instructions. Instead of executing an instruction once and moving on, a loop allows the instruction to repeat itself, typically until a certain condition is met. Consider the process of kneading dough as an analogy. You repeatedly pull and stretch the dough until it reaches the desired consistency. This change in the dough's texture serves as the condition to end the kneading loop. Similarly, imagine pouring milk into a measuring cup. The action of pouring is the repeated instruction. The loop continues until the milk reaches a specific level in the cup, at which point the condition to terminate the loop is met. This process illustrates how loops function in programming, repeating actions efficiently until a defined condition is satisfied. // In math we often represent percents ranging from 0 to 100 // In games we often represent percents as floats ranging from 0 to 1 float doughKneedingProgress = 0.0f; void Start() { // repeat until progress reaches 1.0 while(doughKneedingProgress < 1.0f) { // increase the dough kneeding progress by 1 percent doughKneedingProgress += 0.01f; // output the kneeding progress to console Debug.log($\"Kneeding dough: {doughKneedingProgress * 100}%\"); } // output to console that we are done Debug.log(\"Dough is done!\"); } Imagine a tray filled with cupcakes awaiting frosting. We could design a single function to apply a specific frosting pattern to one cupcake. By executing this function for each cupcake on the tray, effectively repeating the pattern across all cupcakes, we establish a loop. This loop allows us to efficiently apply the same decorative frosting to each cupcake, ensuring consistency and saving time. // tray full of cupcakes CupCake[] cupCakes = new CupCake[10]; void Start() { // make sure to repeat this until we reach all cupcakes for(int i = 0; i < cupCakes.length; i++) { // add frosting over each cupcake CupCakes[i].AddFrosting(); } } We can write the same program slightly simpler, each time we repeat the loop we obtain the correct cupcake. We lost the information about which cupcake we are right now processing which depends on the program we are writing. // tray full of cupcakes CupCake[] cupCakes = new CupCake[10]; void Start() { // make sure to repeat this until we reach all cupcakes foreach(CupCake cupCake in cupCakes) { // add frosting over each cupcake cupCake.AddFrosting(); } } We can also write a loop as a recursive function. This method is rarely used but sometimes it can be handy. // tray full of cupcakes CupCake[] cupCakes = new CupCake[10]; void Start() { AddFrosting(cupCakes, 0); } void AddFrosting(CupCake[] cupCakes, int cupCakeIndex) { if(cupCakeIndex < cupCakes.Length) { cupCakes[cupCakeIndex].AddFrosting(); AddFrosting(cupCakes, cupCakeIndex + 1); } } Loops on Microsoft.com","title":"Loops"},{"location":"csharp/operators.html","text":"Operators Operators in programming are like the tools and techniques used in cooking. Just as different kitchen tools or techniques combine and transform ingredients into a dish, operators manipulate data to produce a result. Assignment operators are like setting your cooking station before you begin preparing a meal. Just as you would assign specific tools and ingredients to their spots on your counter, in programming, you assign values to variables for later use. For example, setting x = 5 is like placing five tomatoes on your counter, ready to be used in your dish. void Start() { // assign a to 5 float a = 5f; // assign the value of a to 6 a = 6; // the value of a is 6 Debug.Log(a); // assign b to 3 float b = 3f; // assign the value of b to the value of a b = a; // the value of b is 6 Debug.Log(b); } Consider basic arithmetic operators, such as addition, subtraction, multiplication, and division. Using these operators is akin to measuring ingredients. For example, adding two numbers ( + ) is like combining two different ingredients in a bowl. Subtracting one number from another ( - ) can be compared to removing an ingredient from a mixture, such as taking a bit of salt out if you've added too much. Multiplication ( * ) could be likened to duplicating a recipe for more servings, effectively increasing each ingredient proportionally. Division ( / ) is akin to dividing a recipe into smaller portions, reducing each ingredient accordingly. void Start() { float a = 5f; float b = 6f; float resultOfAddition = a + b; Debug.Log($\"5 + 6 = {resultOfAddition}\"); float resultOfSubtraction = a - b; Debug.Log($\"5 - 6 = {resultOfSubtraction}\"); float resultOfMultiplication = a * b; Debug.Log($\"5 * 6 = {resultOfMultiplication}\"); float resultOfDivision = a / b; Debug.Log($\"5 / 6 = {resultOfDivision}\"); } This example shows how we can modify an original value using a shorthand operator instead. void Start() { float number = 0; Debug.Log($\"{number} = 0\"); // add 10 to number number += 10f; Debug.Log($\"{number} = 10\"); // subtract 5 from number number -= 5f; Debug.Log($\"{number} = 5\"); // multiply number by 2 number *= 2f; Debug.Log($\"{number} = 10\"); // divide number by 2 number /= 2f; Debug.Log($\"{number} = 5\"); } Continue with conditions Operators on Microsoft.com","title":"Operators"},{"location":"csharp/operators.html#operators","text":"Operators in programming are like the tools and techniques used in cooking. Just as different kitchen tools or techniques combine and transform ingredients into a dish, operators manipulate data to produce a result. Assignment operators are like setting your cooking station before you begin preparing a meal. Just as you would assign specific tools and ingredients to their spots on your counter, in programming, you assign values to variables for later use. For example, setting x = 5 is like placing five tomatoes on your counter, ready to be used in your dish. void Start() { // assign a to 5 float a = 5f; // assign the value of a to 6 a = 6; // the value of a is 6 Debug.Log(a); // assign b to 3 float b = 3f; // assign the value of b to the value of a b = a; // the value of b is 6 Debug.Log(b); } Consider basic arithmetic operators, such as addition, subtraction, multiplication, and division. Using these operators is akin to measuring ingredients. For example, adding two numbers ( + ) is like combining two different ingredients in a bowl. Subtracting one number from another ( - ) can be compared to removing an ingredient from a mixture, such as taking a bit of salt out if you've added too much. Multiplication ( * ) could be likened to duplicating a recipe for more servings, effectively increasing each ingredient proportionally. Division ( / ) is akin to dividing a recipe into smaller portions, reducing each ingredient accordingly. void Start() { float a = 5f; float b = 6f; float resultOfAddition = a + b; Debug.Log($\"5 + 6 = {resultOfAddition}\"); float resultOfSubtraction = a - b; Debug.Log($\"5 - 6 = {resultOfSubtraction}\"); float resultOfMultiplication = a * b; Debug.Log($\"5 * 6 = {resultOfMultiplication}\"); float resultOfDivision = a / b; Debug.Log($\"5 / 6 = {resultOfDivision}\"); } This example shows how we can modify an original value using a shorthand operator instead. void Start() { float number = 0; Debug.Log($\"{number} = 0\"); // add 10 to number number += 10f; Debug.Log($\"{number} = 10\"); // subtract 5 from number number -= 5f; Debug.Log($\"{number} = 5\"); // multiply number by 2 number *= 2f; Debug.Log($\"{number} = 10\"); // divide number by 2 number /= 2f; Debug.Log($\"{number} = 5\"); } Continue with conditions Operators on Microsoft.com","title":"Operators"},{"location":"csharp/programming_vs_cooking.html","text":"Programming vs cooking Programming can be compared to a cooking recipe. Let's start with a simple recipe for a classic dish: Spaghetti Aglio e Olio for 2 people. ### Ingredients: - Spaghetti: 200g - Olive oil: 4 tablespoons - Garlic (finely sliced): 2 cloves - Red pepper flakes: 1/2 teaspoon - Parsley (chopped): 2 tablespoons - Salt: to taste - Freshly ground black pepper: to taste ### Cooking Process: 1. Bring a large pot of salted water to a boil. Add spaghetti and cook until al dente, about 8-10 minutes. Drain, reserving 1 cup of pasta water. 2. While the pasta cooks, heat olive oil in a large pan over medium heat. Add the garlic and red pepper flakes, saut\u00e9ing until the garlic is golden brown, about 2 minutes. 3. Add the drained spaghetti to the pan. Toss well to coat the spaghetti in the olive oil. If the pasta seems dry, add a little of the reserved pasta water until it reaches your desired consistency. 4. Remove from heat. Add the parsley, salt, and black pepper. Toss everything together until the spaghetti is evenly coated. 5. Serve immediately. Programming is similar in that it needs: data and Instructions on how to prepare data in to actual result. // our instructions void Start() { // Example: Adjust recipe for 4 people SpaghettiAglioEOlio(4); } static void SpaghettiAglioEOlio(int people = 2) { // Ingredients for 2 people int spaghettiGrams = 200 * people; int oliveOilTbsp = 4 * people; int garlicCloves = 2 * people; double redPepperFlakesTsp = 0.5 * people; int parsleyTbsp = 2 * people; string salt = \"to taste\"; string blackPepper = \"to taste\"; // print out recipe adjusted to number of people Debug.Log($\"Spaghetti Aglio e Olio Recipe for {people} people:\"); Debug.Log($\"- Spaghetti: {spaghettiGrams}g\"); Debug.Log($\"- Olive oil: {oliveOilTbsp} tablespoons\"); Debug.Log($\"- Garlic (finely sliced): {garlicCloves} cloves\"); Debug.Log($\"- Red pepper flakes: {redPepperFlakesTsp} teaspoon(s)\"); Debug.Log($\"- Parsley (chopped): {parsleyTbsp} tablespoons\"); Debug.Log($\"- Salt: {salt}\"); Debug.Log($\"- Freshly ground black pepper: {blackPepper}\"); Debug.Log(\"Cooking Process:\"); Debug.Log(\"1. Bring a large pot of salted water to a boil.\"); Debug.Log(\"Add spaghetti and cook until al dente.\"); Debug.Log(\"Drain, reserving 1 cup of pasta water.\"); Debug.Log(\"2. Heat olive oil in a pan over medium heat.\"); Debug.Log(\"Add garlic and red pepper, saut\u00e9 until garlic is golden brown.\"); Debug.Log(\"3. Add drained spaghetti to the pan. Toss to coat.\"); Debug.Log(\"Add reserved pasta water as needed.\"); Debug.Log(\"4. Remove from heat. Add parsley, salt, and black pepper.\"); Debug.Log(\"Toss well.\"); Debug.Log(\"5. Serve immediately.\"); } The primary distinction between programming and cooking lies in their respective approaches to precision and variability. Cooking, by its nature, embraces a certain level of vagueness. This inherent ambiguity often leads to varied outcomes, even when individuals follow the same recipe closely. The variability in results is part of the culinary experience, reflecting the artistry and personal touch in cooking. Conversely, the essence of programming and computer science is the creation of a set of instructions designed to consistently produce identical results. This predictability is crucial, serving as a cornerstone for scientific research. However, one need not engage in scientific endeavors to appreciate the reliability that comes with executing a given set of instructions in programming. Programming languages and computers have been meticulously developed to operate with exactitude and determinism, eschewing the subjective measurements (like \"a pinch\" or \"a handful\") commonly found in cooking. This precision ensures that every execution of a program under the same conditions yields the same outcome, unlike the subjective descriptors (\"brownish,\" \"creamy,\" etc.) used in cooking, which often fall short of conveying precise properties. The variability in cooking results from the need to understand and manage numerous factors, such as ingredient behavior under different conditions, moisture content, and cooking times and temperatures. Mastery in cooking parallels the knowledge and expertise of a chemist, as it requires a deep understanding of how elements interact in various scenarios. In programming, clarity and precision are paramount. Programming languages introduce data types to explicitly define the nature and size of data. Functions specify the operations applied to data, outlining clear transformations and expected outcomes. This focus on well-defined data and specific functions highlights programming's emphasis on control and predictability, contrasting with the fluid and often experiential nature of cooking. Start with constants","title":"Intro"},{"location":"csharp/programming_vs_cooking.html#programming-vs-cooking","text":"Programming can be compared to a cooking recipe. Let's start with a simple recipe for a classic dish: Spaghetti Aglio e Olio for 2 people. ### Ingredients: - Spaghetti: 200g - Olive oil: 4 tablespoons - Garlic (finely sliced): 2 cloves - Red pepper flakes: 1/2 teaspoon - Parsley (chopped): 2 tablespoons - Salt: to taste - Freshly ground black pepper: to taste ### Cooking Process: 1. Bring a large pot of salted water to a boil. Add spaghetti and cook until al dente, about 8-10 minutes. Drain, reserving 1 cup of pasta water. 2. While the pasta cooks, heat olive oil in a large pan over medium heat. Add the garlic and red pepper flakes, saut\u00e9ing until the garlic is golden brown, about 2 minutes. 3. Add the drained spaghetti to the pan. Toss well to coat the spaghetti in the olive oil. If the pasta seems dry, add a little of the reserved pasta water until it reaches your desired consistency. 4. Remove from heat. Add the parsley, salt, and black pepper. Toss everything together until the spaghetti is evenly coated. 5. Serve immediately. Programming is similar in that it needs: data and Instructions on how to prepare data in to actual result. // our instructions void Start() { // Example: Adjust recipe for 4 people SpaghettiAglioEOlio(4); } static void SpaghettiAglioEOlio(int people = 2) { // Ingredients for 2 people int spaghettiGrams = 200 * people; int oliveOilTbsp = 4 * people; int garlicCloves = 2 * people; double redPepperFlakesTsp = 0.5 * people; int parsleyTbsp = 2 * people; string salt = \"to taste\"; string blackPepper = \"to taste\"; // print out recipe adjusted to number of people Debug.Log($\"Spaghetti Aglio e Olio Recipe for {people} people:\"); Debug.Log($\"- Spaghetti: {spaghettiGrams}g\"); Debug.Log($\"- Olive oil: {oliveOilTbsp} tablespoons\"); Debug.Log($\"- Garlic (finely sliced): {garlicCloves} cloves\"); Debug.Log($\"- Red pepper flakes: {redPepperFlakesTsp} teaspoon(s)\"); Debug.Log($\"- Parsley (chopped): {parsleyTbsp} tablespoons\"); Debug.Log($\"- Salt: {salt}\"); Debug.Log($\"- Freshly ground black pepper: {blackPepper}\"); Debug.Log(\"Cooking Process:\"); Debug.Log(\"1. Bring a large pot of salted water to a boil.\"); Debug.Log(\"Add spaghetti and cook until al dente.\"); Debug.Log(\"Drain, reserving 1 cup of pasta water.\"); Debug.Log(\"2. Heat olive oil in a pan over medium heat.\"); Debug.Log(\"Add garlic and red pepper, saut\u00e9 until garlic is golden brown.\"); Debug.Log(\"3. Add drained spaghetti to the pan. Toss to coat.\"); Debug.Log(\"Add reserved pasta water as needed.\"); Debug.Log(\"4. Remove from heat. Add parsley, salt, and black pepper.\"); Debug.Log(\"Toss well.\"); Debug.Log(\"5. Serve immediately.\"); } The primary distinction between programming and cooking lies in their respective approaches to precision and variability. Cooking, by its nature, embraces a certain level of vagueness. This inherent ambiguity often leads to varied outcomes, even when individuals follow the same recipe closely. The variability in results is part of the culinary experience, reflecting the artistry and personal touch in cooking. Conversely, the essence of programming and computer science is the creation of a set of instructions designed to consistently produce identical results. This predictability is crucial, serving as a cornerstone for scientific research. However, one need not engage in scientific endeavors to appreciate the reliability that comes with executing a given set of instructions in programming. Programming languages and computers have been meticulously developed to operate with exactitude and determinism, eschewing the subjective measurements (like \"a pinch\" or \"a handful\") commonly found in cooking. This precision ensures that every execution of a program under the same conditions yields the same outcome, unlike the subjective descriptors (\"brownish,\" \"creamy,\" etc.) used in cooking, which often fall short of conveying precise properties. The variability in cooking results from the need to understand and manage numerous factors, such as ingredient behavior under different conditions, moisture content, and cooking times and temperatures. Mastery in cooking parallels the knowledge and expertise of a chemist, as it requires a deep understanding of how elements interact in various scenarios. In programming, clarity and precision are paramount. Programming languages introduce data types to explicitly define the nature and size of data. Functions specify the operations applied to data, outlining clear transformations and expected outcomes. This focus on well-defined data and specific functions highlights programming's emphasis on control and predictability, contrasting with the fluid and often experiential nature of cooking. Start with constants","title":"Programming vs cooking"},{"location":"csharp/scope.html","text":"Scope Think of programming scope like the workspace in a kitchen. In a kitchen, you have different areas designated for specific tasks\u2014there's a spot for preparing vegetables, another for mixing ingredients, and perhaps a station for plating. Each area has its tools and ingredients, accessible only within that space. In programming, scope functions similarly: it defines where variables and functions are accessible. Variables defined within a function (like tools in our vegetable prep area) are available only in that specific function, not elsewhere in the program. Just as you wouldn't use a salad fork to flip a steak on the grill, a variable defined within one function can't be used directly in another, unless it's made available through specific mechanisms, akin to moving an ingredient from one part of the kitchen to another. This organization ensures that our cooking (and coding) environment remains orderly, efficient, and free of unexpected interactions. Each class, struct and function has a body. Where we define our variables affects the accessibility of those variables. variable is accessible only by the body of the class class MyClass { int myVariable; } variable is accessible only by the body of the function class MyClass { void MyFunction() { int myVariable; } } function is accessible only by the body of the class class MyClass { void MyFunction() { } } if we want to make a function or a variable visible outside of the class we need to define in the body of the class and make it public. class MyClass { public void MyFunction() { } } if we want to make a class accessible to other classes. we have to make it public as well. public class MyClass { public void MyFunction() { } } Continue with functions Scope on Microsoft.com","title":"Scope"},{"location":"csharp/scope.html#scope","text":"Think of programming scope like the workspace in a kitchen. In a kitchen, you have different areas designated for specific tasks\u2014there's a spot for preparing vegetables, another for mixing ingredients, and perhaps a station for plating. Each area has its tools and ingredients, accessible only within that space. In programming, scope functions similarly: it defines where variables and functions are accessible. Variables defined within a function (like tools in our vegetable prep area) are available only in that specific function, not elsewhere in the program. Just as you wouldn't use a salad fork to flip a steak on the grill, a variable defined within one function can't be used directly in another, unless it's made available through specific mechanisms, akin to moving an ingredient from one part of the kitchen to another. This organization ensures that our cooking (and coding) environment remains orderly, efficient, and free of unexpected interactions. Each class, struct and function has a body. Where we define our variables affects the accessibility of those variables. variable is accessible only by the body of the class class MyClass { int myVariable; } variable is accessible only by the body of the function class MyClass { void MyFunction() { int myVariable; } } function is accessible only by the body of the class class MyClass { void MyFunction() { } } if we want to make a function or a variable visible outside of the class we need to define in the body of the class and make it public. class MyClass { public void MyFunction() { } } if we want to make a class accessible to other classes. we have to make it public as well. public class MyClass { public void MyFunction() { } } Continue with functions Scope on Microsoft.com","title":"Scope"},{"location":"csharp/types.html","text":"Types Every ingredient possesses a unique flavor profile, akin to how in programming, each data type has distinct characteristics. Consider the nutritional content of our cooking ingredients: some are rich in fats, others in proteins. The ratio of fats to proteins can significantly alter the flavor of a dish, leading us to categorize ingredients based on their nutritional makeup. Among our culinary repertoire, certain ingredients serve as the foundation of countless dishes. Take, for instance, tomatoes, eggs, and salmon. Each of these can be seen as a fundamental building block in the culinary world. When we combine these base ingredients, such as in a salad, we're not just mixing flavors; we're creating something new from the foundational elements. A salad represents a harmonious blend of these basic components. This culinary concept mirrors the structure of programming languages. In programming, we have fundamental elements known as primitive data types. These are the basic ingredients from which we start - akin to our tomatoes, eggs, and salmon. And just as combining these ingredients can create a salad, in programming, when we combine primitive types, we create what are known as composite types. Primitive data types are the simple, indivisible types that form the basis of programming. These include types like integers, booleans, and characters - each serving a unique purpose and representing different kinds of data. Composite types, on the other hand, are akin to our salads. They're formed by combining primitive types or other composite types into more complex structures. Examples include arrays, structures, and classes. Just as a salad brings together various flavors into a cohesive dish, composite types combine simpler data types to create more intricate and versatile data structures. primitive types bool | boolean | binary true or false bool positive = true; bool negative = false; char | character | single letter value char letterA = 'a'; char letterB = 'b'; int | integer | whole number int positiveNumber = 24; int negativeNumber = -126; float | float | floating point number float positiveFloatingNumber = 3.14f; float negativeFloatingNumber = -126.0f; double | double | double precision floating point number double positiveFloatingNumber = 3.14; double negativeFloatingNumber = -126.0; enum | enumeration | list of options represented by a whole number enum myEnum { firstEnum, secondEnum thirdEnum } composite types [] | array | multiple elements bool[] arrayOfBooleans; char[] arrayOfCharacters; int[] arrayOfIntegers; float[] arrayOfFloats; double[] arrayOfDoubles; string | string | array of characters, text string myString = \"this is my first string\"; struct | structure | container containing multiple variables struct MyStruct { // body of MyStruct bool[] myArrayOfBools; int myInteger; float myFloat; string myString; } class | class | container containing multiple variables and functions class MyClass { // body of MyClass bool[] myArrayOfBools; int myInteger; float myFloat; string myString; void MyFunction() { // body of MyFunction } } Continue with scope Types on Microsoft.com","title":"Types"},{"location":"csharp/types.html#types","text":"Every ingredient possesses a unique flavor profile, akin to how in programming, each data type has distinct characteristics. Consider the nutritional content of our cooking ingredients: some are rich in fats, others in proteins. The ratio of fats to proteins can significantly alter the flavor of a dish, leading us to categorize ingredients based on their nutritional makeup. Among our culinary repertoire, certain ingredients serve as the foundation of countless dishes. Take, for instance, tomatoes, eggs, and salmon. Each of these can be seen as a fundamental building block in the culinary world. When we combine these base ingredients, such as in a salad, we're not just mixing flavors; we're creating something new from the foundational elements. A salad represents a harmonious blend of these basic components. This culinary concept mirrors the structure of programming languages. In programming, we have fundamental elements known as primitive data types. These are the basic ingredients from which we start - akin to our tomatoes, eggs, and salmon. And just as combining these ingredients can create a salad, in programming, when we combine primitive types, we create what are known as composite types. Primitive data types are the simple, indivisible types that form the basis of programming. These include types like integers, booleans, and characters - each serving a unique purpose and representing different kinds of data. Composite types, on the other hand, are akin to our salads. They're formed by combining primitive types or other composite types into more complex structures. Examples include arrays, structures, and classes. Just as a salad brings together various flavors into a cohesive dish, composite types combine simpler data types to create more intricate and versatile data structures.","title":"Types"},{"location":"csharp/types.html#primitive-types","text":"bool | boolean | binary true or false bool positive = true; bool negative = false; char | character | single letter value char letterA = 'a'; char letterB = 'b'; int | integer | whole number int positiveNumber = 24; int negativeNumber = -126; float | float | floating point number float positiveFloatingNumber = 3.14f; float negativeFloatingNumber = -126.0f; double | double | double precision floating point number double positiveFloatingNumber = 3.14; double negativeFloatingNumber = -126.0; enum | enumeration | list of options represented by a whole number enum myEnum { firstEnum, secondEnum thirdEnum }","title":"primitive types"},{"location":"csharp/types.html#composite-types","text":"[] | array | multiple elements bool[] arrayOfBooleans; char[] arrayOfCharacters; int[] arrayOfIntegers; float[] arrayOfFloats; double[] arrayOfDoubles; string | string | array of characters, text string myString = \"this is my first string\"; struct | structure | container containing multiple variables struct MyStruct { // body of MyStruct bool[] myArrayOfBools; int myInteger; float myFloat; string myString; } class | class | container containing multiple variables and functions class MyClass { // body of MyClass bool[] myArrayOfBools; int myInteger; float myFloat; string myString; void MyFunction() { // body of MyFunction } } Continue with scope Types on Microsoft.com","title":"composite types"},{"location":"csharp/variables.html","text":"Variables Just as constants are akin to the staple ingredients in our culinary analogy, variables in programming are like the versatile ingredients found in a kitchen, such as vegetables, meats, or spices, whose quantities and types might change depending on the dish being prepared. In cooking, a chef might adjust these ingredients based on taste preference, the number of servings, or even the ingredients available at the moment. This flexibility allows for a wide range of dishes to be created from a basic set of ingredients, each tailored to the occasion. Similarly, variables in a programming context are named storage locations that can hold different values over time. Just like adjusting the amount of carrots in a stew or the type of cheese in a pasta dish can dramatically alter the flavor profile, changing the values stored in variables affects the behavior and output of a program. Variables provide the flexibility to process and manipulate data dynamically, responding to user input, external data, or the program's internal state changes. This adaptability is essential for creating responsive, efficient, and complex software systems. Variable is always defined by: type name = value; Variables can be assigned int integerNumber = 5; float floatingPointNumber = 5.5f; double doubleFloatingPointNumber = 5.5; bool boolean = true; char singleCharacter = 's'; string text = \"this is a plain text\"; Variables can be also unassigned int integerNumber; // default value is 0 float floatingPointNumber; // default value is 0f double doubleFloatingPointNumber; // default value is 0.0 bool boolean; // default value is false char singleCharacter; // default value is '\\0' string text; // default value is null Unassigned variables are always assigned by the compiler with its default value specified by the type. Default value of any type can be obtained by calling: default(int); // 0 default(float); // 0f default(double); // 0.0 default(bool); // false default(char); // '\\0' default(string); // null Variable names 1variable \u274c do not start names with a number ko\u010di\u010dka$#. \u274c do not use special symbols my variable \u274c do not use spaces MyVariable \u274c do not start variable name with upper case my_variable \u2705 you can use underscores instead of spaces myVariable \u2705 use camel case instead of spaces Continue with types Variables on Microsoft.com","title":"Variables"},{"location":"csharp/variables.html#variables","text":"Just as constants are akin to the staple ingredients in our culinary analogy, variables in programming are like the versatile ingredients found in a kitchen, such as vegetables, meats, or spices, whose quantities and types might change depending on the dish being prepared. In cooking, a chef might adjust these ingredients based on taste preference, the number of servings, or even the ingredients available at the moment. This flexibility allows for a wide range of dishes to be created from a basic set of ingredients, each tailored to the occasion. Similarly, variables in a programming context are named storage locations that can hold different values over time. Just like adjusting the amount of carrots in a stew or the type of cheese in a pasta dish can dramatically alter the flavor profile, changing the values stored in variables affects the behavior and output of a program. Variables provide the flexibility to process and manipulate data dynamically, responding to user input, external data, or the program's internal state changes. This adaptability is essential for creating responsive, efficient, and complex software systems. Variable is always defined by: type name = value; Variables can be assigned int integerNumber = 5; float floatingPointNumber = 5.5f; double doubleFloatingPointNumber = 5.5; bool boolean = true; char singleCharacter = 's'; string text = \"this is a plain text\"; Variables can be also unassigned int integerNumber; // default value is 0 float floatingPointNumber; // default value is 0f double doubleFloatingPointNumber; // default value is 0.0 bool boolean; // default value is false char singleCharacter; // default value is '\\0' string text; // default value is null Unassigned variables are always assigned by the compiler with its default value specified by the type. Default value of any type can be obtained by calling: default(int); // 0 default(float); // 0f default(double); // 0.0 default(bool); // false default(char); // '\\0' default(string); // null Variable names 1variable \u274c do not start names with a number ko\u010di\u010dka$#. \u274c do not use special symbols my variable \u274c do not use spaces MyVariable \u274c do not start variable name with upper case my_variable \u2705 you can use underscores instead of spaces myVariable \u2705 use camel case instead of spaces Continue with types Variables on Microsoft.com","title":"Variables"},{"location":"game_dev/building_blocks/camera.html","text":"Camera Without a proper camera in our game we would be unable to see the player or the world. A camera is trying to mimic a physical camera in real world. It has a position, orientation, aspect ratio and field of view. When we talk about cameras in games we usually refer to their behavior. Individual camera behaviors can change the whole genre of the game, therefore it can be coined as one of the most important building block in our game. Most common camera behaviors in games Fixed camera Resident evil 2 You just place your camera in the scene without any script Follow camera Super Mario Bros 3 Simplest camera which just follows the target with slight delay First person camera CS GO Slightly advanced camera which allows the player to look around Third person camera Red Dead Redemption Advanced camera which adds certain offset from player. The movement of the camera is called camera orbit as it orbits around the player. When the camera detects collision between player and camera it comes closer to prevent occlusion. It allows custom distance from player by using mouse scroll wheel.","title":"Camera"},{"location":"game_dev/building_blocks/camera.html#camera","text":"Without a proper camera in our game we would be unable to see the player or the world. A camera is trying to mimic a physical camera in real world. It has a position, orientation, aspect ratio and field of view. When we talk about cameras in games we usually refer to their behavior. Individual camera behaviors can change the whole genre of the game, therefore it can be coined as one of the most important building block in our game. Most common camera behaviors in games","title":"Camera"},{"location":"game_dev/building_blocks/camera.html#fixed-camera","text":"Resident evil 2 You just place your camera in the scene without any script","title":"Fixed camera"},{"location":"game_dev/building_blocks/camera.html#follow-camera","text":"Super Mario Bros 3 Simplest camera which just follows the target with slight delay","title":"Follow camera"},{"location":"game_dev/building_blocks/camera.html#first-person-camera","text":"CS GO Slightly advanced camera which allows the player to look around","title":"First person camera"},{"location":"game_dev/building_blocks/camera.html#third-person-camera","text":"Red Dead Redemption Advanced camera which adds certain offset from player. The movement of the camera is called camera orbit as it orbits around the player. When the camera detects collision between player and camera it comes closer to prevent occlusion. It allows custom distance from player by using mouse scroll wheel.","title":"Third person camera"},{"location":"game_dev/building_blocks/chance.html","text":"Chance In games pure luck or chance are often important to make the game more interesting or to make the game playable more than once. Fallout luck fairy In game engines we talk about chance as randomness. We use a random number generator which acts similar to a board game dice. When designing games with randomness in mind, it is quite important to also keep in mind the odds of a certain event happening. Imagine that if we have a 2 sided dice, we have 1/2 therefore 50% probability of an specific event occurring. If we have a 6 sided dice the probability of an event happening becomes 1/6 therefore 16%. To obtain a random number we need a function which generates random numbers and a seed. Seed is a special number which makes sure that our random generation stays always the same. We want the randomly generated numbers to stay the same each run so we can actually test the game and find bugs.","title":"Chance"},{"location":"game_dev/building_blocks/chance.html#chance","text":"In games pure luck or chance are often important to make the game more interesting or to make the game playable more than once. Fallout luck fairy In game engines we talk about chance as randomness. We use a random number generator which acts similar to a board game dice. When designing games with randomness in mind, it is quite important to also keep in mind the odds of a certain event happening. Imagine that if we have a 2 sided dice, we have 1/2 therefore 50% probability of an specific event occurring. If we have a 6 sided dice the probability of an event happening becomes 1/6 therefore 16%. To obtain a random number we need a function which generates random numbers and a seed. Seed is a special number which makes sure that our random generation stays always the same. We want the randomly generated numbers to stay the same each run so we can actually test the game and find bugs.","title":"Chance"},{"location":"game_dev/building_blocks/character_controller.html","text":"Character controller Is the second most important element in most games. It can be as simple as a dot navigating on a grid and as complex as Assassin's Creed character which climbs and runs on walls or Spider man character which can swing from building to building. The main objective is designing players behavior. We need to limit our character abilities to fit our level design. Super mario bros character controller Basic Character controller Our example character controller can walk, run and jump. More advanced character controllers could do a even more. double jump, fly, dive, climb, wall run. Those abilities are called states. The complexity of the character controller depends on how many states in can be and how complicated the state it self is. Super mario 64 triple jump Assassin's Creed jump CS GO surfing Going from one state to another is called state transition. State transitions can be done by certain button or walking near a specific trigger. Wall climbing state could be activated when walking near wall. Ladder climbing can be activated by a specific button near a ladder. Designing character controllers is a very specific discipline and has usually a dedicated game designer who works in tandem with a level designer.","title":"Character controller"},{"location":"game_dev/building_blocks/character_controller.html#character-controller","text":"Is the second most important element in most games. It can be as simple as a dot navigating on a grid and as complex as Assassin's Creed character which climbs and runs on walls or Spider man character which can swing from building to building. The main objective is designing players behavior. We need to limit our character abilities to fit our level design. Super mario bros character controller","title":"Character controller"},{"location":"game_dev/building_blocks/character_controller.html#basic-character-controller","text":"Our example character controller can walk, run and jump. More advanced character controllers could do a even more. double jump, fly, dive, climb, wall run. Those abilities are called states. The complexity of the character controller depends on how many states in can be and how complicated the state it self is. Super mario 64 triple jump Assassin's Creed jump CS GO surfing Going from one state to another is called state transition. State transitions can be done by certain button or walking near a specific trigger. Wall climbing state could be activated when walking near wall. Ladder climbing can be activated by a specific button near a ladder. Designing character controllers is a very specific discipline and has usually a dedicated game designer who works in tandem with a level designer.","title":"Basic Character controller"},{"location":"game_dev/building_blocks/console.html","text":"Console Every game, every program and everything on your PC starts with a console. It is the simplest form of user input and visual feedback a computer can represent. Consoles in games are heavily used for script debugging, collecting bread crumbs, making sure that certain parts of your program did run properly and also for logging errors. The matrix Therefore a console is the biggest friend of any developer. This simple script will provide us a public function which can be used in the unity editor to debug custom messages or events. It is the simplest program we can write and it is often called Hello World!","title":"Console"},{"location":"game_dev/building_blocks/console.html#console","text":"Every game, every program and everything on your PC starts with a console. It is the simplest form of user input and visual feedback a computer can represent. Consoles in games are heavily used for script debugging, collecting bread crumbs, making sure that certain parts of your program did run properly and also for logging errors. The matrix Therefore a console is the biggest friend of any developer. This simple script will provide us a public function which can be used in the unity editor to debug custom messages or events. It is the simplest program we can write and it is often called Hello World!","title":"Console"},{"location":"game_dev/building_blocks/counters.html","text":"Counters Counter can represent score, level or currency. It is used for keeping track of player progress, level progress or amount of currency held. Platformer game would use score as number of stars collected. Zombie game could represent the amount of zombies killed. Strategy game would represent amount of gold we have extracted. RPG game, level would show how much skill have we gained by progressing in the game. World of warcraft level up Lifetime It is important to know the lifetime of a counter. Mini game/mission , means it will reset whenever a mini game is triggered. Level , means it will reset whenever another level loads. Game , means it will reset whenever we quit the game. Save slot , means it will reset whenever we create a new save slot. Owners It is good to know who that counter belongs to. player , obviously most common location would be our player Other players , in a multiplayer game we want to know score of our friends. NPCs , when we want to loot an NPC we need to know their amount of currency. Inventory , we can store currency inside chests or inventories as well. Modifiers The game needs to be able to modify the counter during certain game events. Add , during game we need to add the counter whenever player collects a star or kills a zombie. Subtract , during game we want to remove some counter progress, we can do it as a form of punishment or we can use it as consumable. Spending our counter as currency for exchanging goods or power-ups. Multiply , special bonus in our game can double or triple our existing score. Divide , our counter can also represent a negative effect, so diving its value would decrease that effect. Listeners We often need to present score or currency to the player to inform about our progress. If we collect stars and do not see that a counter has increased the player does not understand that we keep track of it. UI , most common reader is the user interface where we present how much has score increased or decreased during gameplay. Trigger , can open doors for example when the counter has reached certain value. Merchant , NPCs in games can trade goods with us, but without keeping track of currency we could be buying their entire inventory in just few seconds. Counter","title":"Counters"},{"location":"game_dev/building_blocks/counters.html#counters","text":"Counter can represent score, level or currency. It is used for keeping track of player progress, level progress or amount of currency held. Platformer game would use score as number of stars collected. Zombie game could represent the amount of zombies killed. Strategy game would represent amount of gold we have extracted. RPG game, level would show how much skill have we gained by progressing in the game. World of warcraft level up","title":"Counters"},{"location":"game_dev/building_blocks/counters.html#lifetime","text":"It is important to know the lifetime of a counter. Mini game/mission , means it will reset whenever a mini game is triggered. Level , means it will reset whenever another level loads. Game , means it will reset whenever we quit the game. Save slot , means it will reset whenever we create a new save slot.","title":"Lifetime"},{"location":"game_dev/building_blocks/counters.html#owners","text":"It is good to know who that counter belongs to. player , obviously most common location would be our player Other players , in a multiplayer game we want to know score of our friends. NPCs , when we want to loot an NPC we need to know their amount of currency. Inventory , we can store currency inside chests or inventories as well.","title":"Owners"},{"location":"game_dev/building_blocks/counters.html#modifiers","text":"The game needs to be able to modify the counter during certain game events. Add , during game we need to add the counter whenever player collects a star or kills a zombie. Subtract , during game we want to remove some counter progress, we can do it as a form of punishment or we can use it as consumable. Spending our counter as currency for exchanging goods or power-ups. Multiply , special bonus in our game can double or triple our existing score. Divide , our counter can also represent a negative effect, so diving its value would decrease that effect.","title":"Modifiers"},{"location":"game_dev/building_blocks/counters.html#listeners","text":"We often need to present score or currency to the player to inform about our progress. If we collect stars and do not see that a counter has increased the player does not understand that we keep track of it. UI , most common reader is the user interface where we present how much has score increased or decreased during gameplay. Trigger , can open doors for example when the counter has reached certain value. Merchant , NPCs in games can trade goods with us, but without keeping track of currency we could be buying their entire inventory in just few seconds.","title":"Listeners"},{"location":"game_dev/building_blocks/counters.html#counter","text":"","title":"Counter"},{"location":"game_dev/building_blocks/inventory.html","text":"Inventory An inventory in a game is a virtual space which stores game elements. Those specific elements are not present in the game world when they are in inventory. Inventory just holds the information that the element can be brought up to the game if needed. Chest Chests is a very useful game mechanic in games, they gives us a sense of surprise or serve us a safe place where to store our valuables. Chests are usually static, placed somewhere so we can find them and function as a temporary storage room. Minecraft chest inventory Player inventory Player inventory can be though of as a backpack. As in real life we store things in our pockets and backpacks. The functionality is exactly the same as with a chest, just the inventory is attached to a moving object, usually us the player. But it can be also on a horse or a car, it depends on the game. Minecraft player inventory Implementation Inventory can be implemented as a single Array. - Array - Continuous , elements are stored in continuous arrangement. First element is stored at first place in the array, Second element at the second place and so on. - Length , An array has to specify its length or size so we can tell what is the maximum amount of elements an Array can hold. Work in progress...","title":"Inventory"},{"location":"game_dev/building_blocks/inventory.html#inventory","text":"An inventory in a game is a virtual space which stores game elements. Those specific elements are not present in the game world when they are in inventory. Inventory just holds the information that the element can be brought up to the game if needed.","title":"Inventory"},{"location":"game_dev/building_blocks/inventory.html#chest","text":"Chests is a very useful game mechanic in games, they gives us a sense of surprise or serve us a safe place where to store our valuables. Chests are usually static, placed somewhere so we can find them and function as a temporary storage room. Minecraft chest inventory","title":"Chest"},{"location":"game_dev/building_blocks/inventory.html#player-inventory","text":"Player inventory can be though of as a backpack. As in real life we store things in our pockets and backpacks. The functionality is exactly the same as with a chest, just the inventory is attached to a moving object, usually us the player. But it can be also on a horse or a car, it depends on the game. Minecraft player inventory","title":"Player inventory"},{"location":"game_dev/building_blocks/inventory.html#implementation","text":"Inventory can be implemented as a single Array. - Array - Continuous , elements are stored in continuous arrangement. First element is stored at first place in the array, Second element at the second place and so on. - Length , An array has to specify its length or size so we can tell what is the maximum amount of elements an Array can hold. Work in progress...","title":"Implementation"},{"location":"game_dev/building_blocks/map.html","text":"Map Usually in open world games navigation can be challenging similar to real world. Some games even when they are corridor based have complex map layout and therefore a map can be helpful. Map can be also present checkpoints and landmarks in a less intrusive way compared to light beams or arrows inside the game it self. Minimap Is presented as HUD element on the game screen. It can be hand drawn by an artist, which can be challenging when the level design changes during development or it can be automatically generated by the game engine, which is a more scalable solution. The level it self contains a special layer with geometry which is draw only in the minimap or large map. The game camera cant see the minimap geometry and the minimap topdown camera cant see the game geometry. Red dead redemption II mini map Large map Large maps can be hand drawn, stylised, or automatically generated similar to a minimap. But they also contain panning and zooming. Kingdom Come deliverence large map Treasure map Is usually a simple image of a hand drawn map, more like a doodle which shows a landmark similar to what is on map and a cross sign which identifies as a treasure or secret location. Inventory maps can be fun to search for, because they require more attention to your environment then during regular gameplay. Red dead redemption II treasure map Checkpoints Are target highlighted on the map and visualise certain important location. Such an location can be for example a starting point of a mission. Grand theft auto series use mission checkpoints to visualise the start of a progress in a campaign or identifies a side quest or side mission which are not important to the main storyline. Routes Some games visualise a specific route almost like a GPS. In open world games it can be hard to navigate through the world, because in the direction of our mission we can have a very long wall, cliff or a river and it could take a lot of time to find a way to cross it, routes can shorten us the time to find an optimal route towards our goal. Areas Some games visualise areas on map with different colours. Thos ereas can identify that certain portion of map is dangerous, or it belongs to a specific gang, race or species and if our character is not ally to that, it will certainly put us in a greater danger. GTA San Andreas gang areas Work in progress...","title":"Map"},{"location":"game_dev/building_blocks/map.html#map","text":"Usually in open world games navigation can be challenging similar to real world. Some games even when they are corridor based have complex map layout and therefore a map can be helpful. Map can be also present checkpoints and landmarks in a less intrusive way compared to light beams or arrows inside the game it self.","title":"Map"},{"location":"game_dev/building_blocks/map.html#minimap","text":"Is presented as HUD element on the game screen. It can be hand drawn by an artist, which can be challenging when the level design changes during development or it can be automatically generated by the game engine, which is a more scalable solution. The level it self contains a special layer with geometry which is draw only in the minimap or large map. The game camera cant see the minimap geometry and the minimap topdown camera cant see the game geometry. Red dead redemption II mini map","title":"Minimap"},{"location":"game_dev/building_blocks/map.html#large-map","text":"Large maps can be hand drawn, stylised, or automatically generated similar to a minimap. But they also contain panning and zooming. Kingdom Come deliverence large map","title":"Large map"},{"location":"game_dev/building_blocks/map.html#treasure-map","text":"Is usually a simple image of a hand drawn map, more like a doodle which shows a landmark similar to what is on map and a cross sign which identifies as a treasure or secret location. Inventory maps can be fun to search for, because they require more attention to your environment then during regular gameplay. Red dead redemption II treasure map","title":"Treasure map"},{"location":"game_dev/building_blocks/map.html#checkpoints","text":"Are target highlighted on the map and visualise certain important location. Such an location can be for example a starting point of a mission. Grand theft auto series use mission checkpoints to visualise the start of a progress in a campaign or identifies a side quest or side mission which are not important to the main storyline.","title":"Checkpoints"},{"location":"game_dev/building_blocks/map.html#routes","text":"Some games visualise a specific route almost like a GPS. In open world games it can be hard to navigate through the world, because in the direction of our mission we can have a very long wall, cliff or a river and it could take a lot of time to find a way to cross it, routes can shorten us the time to find an optimal route towards our goal.","title":"Routes"},{"location":"game_dev/building_blocks/map.html#areas","text":"Some games visualise areas on map with different colours. Thos ereas can identify that certain portion of map is dangerous, or it belongs to a specific gang, race or species and if our character is not ally to that, it will certainly put us in a greater danger. GTA San Andreas gang areas Work in progress...","title":"Areas"},{"location":"game_dev/building_blocks/quests.html","text":"Quests Many RPG games have quests or objectives. Most modern games even if they are casual and don't represent them selves as RPG games have some sort of objectives. The Elder Scrolls V: Skyrim quests A quest is basically a task and a quest log is just a Todo list. Quest needs a unique name so it can be easily understood by the player but also remembered by the game it self that it has been already completed. Quest This quest lives inside the project, therefore is unique per project. In order to react to changes to the quest we need a listener which lives in the scene. Quest Listener Linear quests First quest must finish in order so we can advance to the next quest. The benefit of linear quests is that there is a clear progression, the player is not overwhelmed with decisions on which quest to start. This is usually the main storyline. Linear Quest Log The linear quest log lives again in our project. In order so we can react to changes to the quest log in our scene we need to create a listener. Linear Quest Log Listener Parallel quests When navigating large scale world, we can encounter many NPCs which can give us small quests, we don't have to start or finish those tasks immediately. The benefit is that the player decides on which tasks to take and in which order, but it can also put pressure on the player to decide which task to start or that they have unfinished quests which they don't want to finish. This is usually kept for side missions which are not important for the main storyline. Work in progress...","title":"Quests"},{"location":"game_dev/building_blocks/quests.html#quests","text":"Many RPG games have quests or objectives. Most modern games even if they are casual and don't represent them selves as RPG games have some sort of objectives. The Elder Scrolls V: Skyrim quests A quest is basically a task and a quest log is just a Todo list. Quest needs a unique name so it can be easily understood by the player but also remembered by the game it self that it has been already completed.","title":"Quests"},{"location":"game_dev/building_blocks/quests.html#quest","text":"This quest lives inside the project, therefore is unique per project. In order to react to changes to the quest we need a listener which lives in the scene.","title":"Quest"},{"location":"game_dev/building_blocks/quests.html#quest-listener","text":"","title":"Quest Listener"},{"location":"game_dev/building_blocks/quests.html#linear-quests","text":"First quest must finish in order so we can advance to the next quest. The benefit of linear quests is that there is a clear progression, the player is not overwhelmed with decisions on which quest to start. This is usually the main storyline.","title":"Linear quests"},{"location":"game_dev/building_blocks/quests.html#linear-quest-log","text":"The linear quest log lives again in our project. In order so we can react to changes to the quest log in our scene we need to create a listener.","title":"Linear Quest Log"},{"location":"game_dev/building_blocks/quests.html#linear-quest-log-listener","text":"","title":"Linear Quest Log Listener"},{"location":"game_dev/building_blocks/quests.html#parallel-quests","text":"When navigating large scale world, we can encounter many NPCs which can give us small quests, we don't have to start or finish those tasks immediately. The benefit is that the player decides on which tasks to take and in which order, but it can also put pressure on the player to decide which task to start or that they have unfinished quests which they don't want to finish. This is usually kept for side missions which are not important for the main storyline. Work in progress...","title":"Parallel quests"},{"location":"game_dev/building_blocks/spawners.html","text":"spawners Spawners are areas which spawn specific units. Those units can be enemies, loot, npcs basically everything in the game which needs to respawn at a certain time is considered spawner. Minecraft monster spawner Object to spawn We have to spawn something, otherwise it would be not considered a spawner. That something is usually a game element or a unit. Event The object has to spawn at a specific time called event. We usually spawn things at a specific interval, for example once in a minute. Or we spawn things when we kill an enemy, another enemy is spawned, therefore the number of enemies remains constant. Instance Spawner In combination with a timer we clone the spawned game object every duration we set. This implementation has few issues however. The longer the spawner exists the more it spawns objects which might in best case decrease our game frame rate and in worst case crash our game. This can be resolved by a another timer which destroys the spawned objects Spawning GameObjects can create hiccups in our game, which will affect smoothness of our gameplay. So what can we do to make this safer? Lets use a memory pool. A memory pool is just an array of GameObjects which are instantiated when needed. Individual objects are disabled and when the spawner is about to spawn an object it just moves the object to the spawn location, resets all its states and turns its visibility on. Memory pool Usually we don't want to spawn many new elements at once because they very often cause hiccups. A hiccup in a game is caused by some operation which takes too much time. If we create elements when the game loads instead ahead of time, we still get some hiccup but it is during level loading which is more acceptable. Then during spawning we just enable and disable those elements, which creates the same effect as spawning but without the hiccup. Implementation Spawner can be implemented as: - Array , an array of elements which represents our memory pool. - Integer , representing the current index of an element we want to spawn. - Spawn function , which enables our element in scene and increments the spawn index. - Spawn event - Timer, when our timer finishes, we spawn another element. - Game event, when our enemy is killed, we spawn another enemy. Memory Pool Spawner While this implementation is much more efficient, the crucial portion of this implementation is the resetting of state every time we need to spawn the object. If the Object has complex states, for example animations, physics or game logic that also needs to be reset whenever we need to spawn an object. Keep this in mind, the more complex the state, the more complex the reset becomes as well. In a complex reset state might be actually simpler to use the creation and destruction as this always resets the state to its beginning.","title":"Spawners"},{"location":"game_dev/building_blocks/spawners.html#spawners","text":"Spawners are areas which spawn specific units. Those units can be enemies, loot, npcs basically everything in the game which needs to respawn at a certain time is considered spawner. Minecraft monster spawner","title":"spawners"},{"location":"game_dev/building_blocks/spawners.html#object-to-spawn","text":"We have to spawn something, otherwise it would be not considered a spawner. That something is usually a game element or a unit.","title":"Object to spawn"},{"location":"game_dev/building_blocks/spawners.html#event","text":"The object has to spawn at a specific time called event. We usually spawn things at a specific interval, for example once in a minute. Or we spawn things when we kill an enemy, another enemy is spawned, therefore the number of enemies remains constant.","title":"Event"},{"location":"game_dev/building_blocks/spawners.html#instance-spawner","text":"In combination with a timer we clone the spawned game object every duration we set. This implementation has few issues however. The longer the spawner exists the more it spawns objects which might in best case decrease our game frame rate and in worst case crash our game. This can be resolved by a another timer which destroys the spawned objects Spawning GameObjects can create hiccups in our game, which will affect smoothness of our gameplay. So what can we do to make this safer? Lets use a memory pool. A memory pool is just an array of GameObjects which are instantiated when needed. Individual objects are disabled and when the spawner is about to spawn an object it just moves the object to the spawn location, resets all its states and turns its visibility on.","title":"Instance Spawner"},{"location":"game_dev/building_blocks/spawners.html#memory-pool","text":"Usually we don't want to spawn many new elements at once because they very often cause hiccups. A hiccup in a game is caused by some operation which takes too much time. If we create elements when the game loads instead ahead of time, we still get some hiccup but it is during level loading which is more acceptable. Then during spawning we just enable and disable those elements, which creates the same effect as spawning but without the hiccup.","title":"Memory pool"},{"location":"game_dev/building_blocks/spawners.html#implementation","text":"Spawner can be implemented as: - Array , an array of elements which represents our memory pool. - Integer , representing the current index of an element we want to spawn. - Spawn function , which enables our element in scene and increments the spawn index. - Spawn event - Timer, when our timer finishes, we spawn another element. - Game event, when our enemy is killed, we spawn another enemy.","title":"Implementation"},{"location":"game_dev/building_blocks/spawners.html#memory-pool-spawner","text":"While this implementation is much more efficient, the crucial portion of this implementation is the resetting of state every time we need to spawn the object. If the Object has complex states, for example animations, physics or game logic that also needs to be reset whenever we need to spawn an object. Keep this in mind, the more complex the state, the more complex the reset becomes as well. In a complex reset state might be actually simpler to use the creation and destruction as this always resets the state to its beginning.","title":"Memory Pool Spawner"},{"location":"game_dev/building_blocks/teleports.html","text":"Teleports or portals Teleports and portals can save the player some time or they can transport the player to a different place on the map, which can cause disorientation and excitement. The most common use case of a teleport is when player dies. When the player dies he needs to spawn at a certain location called spawn point. Portal, infinite portal Trigger We first need a trigger which detects the player and maybe our objects as well. Teleportation point Then we need a specific place on the map to which the teleport or portal will transport us. Implementation Trigger, which detects that player or objects has entered the teleport Position, which tells where to teleport our player or object Move player to a specific position Teleport Transform This is the simplest teleport we can make. However, it has a major flaw. If our object contains a RigidBody the teleportation might fail due to collision detection. When we move RigidBodies around, they still have to detect collisions and if there is a wall in the way, the player might get stuck. Lets make this teleport compatible with RigidBodies then. Teleport Rigidbody Now our teleport actually supports moving RigidBodies around. But we might want to filter only specific objects to be able to teleport. We can use object tag as a filter.","title":"Teleports"},{"location":"game_dev/building_blocks/teleports.html#teleports-or-portals","text":"Teleports and portals can save the player some time or they can transport the player to a different place on the map, which can cause disorientation and excitement. The most common use case of a teleport is when player dies. When the player dies he needs to spawn at a certain location called spawn point. Portal, infinite portal","title":"Teleports or portals"},{"location":"game_dev/building_blocks/teleports.html#trigger","text":"We first need a trigger which detects the player and maybe our objects as well.","title":"Trigger"},{"location":"game_dev/building_blocks/teleports.html#teleportation-point","text":"Then we need a specific place on the map to which the teleport or portal will transport us.","title":"Teleportation point"},{"location":"game_dev/building_blocks/teleports.html#implementation","text":"Trigger, which detects that player or objects has entered the teleport Position, which tells where to teleport our player or object Move player to a specific position","title":"Implementation"},{"location":"game_dev/building_blocks/teleports.html#teleport-transform","text":"This is the simplest teleport we can make. However, it has a major flaw. If our object contains a RigidBody the teleportation might fail due to collision detection. When we move RigidBodies around, they still have to detect collisions and if there is a wall in the way, the player might get stuck. Lets make this teleport compatible with RigidBodies then.","title":"Teleport Transform"},{"location":"game_dev/building_blocks/teleports.html#teleport-rigidbody","text":"Now our teleport actually supports moving RigidBodies around. But we might want to filter only specific objects to be able to teleport. We can use object tag as a filter.","title":"Teleport Rigidbody"},{"location":"game_dev/building_blocks/timers.html","text":"Timers Timers are essential blocks for timing certain events. Certain portions of gameplay can be restricted by a timer. Super Mario Bros has a level timer by which the player has to finish the level, otherwise he dies. Super Smash Bros has a match timer which limits the duration of a match during which players have to defeat one another. Timers play an essential role in many aspects of game play. Spawner has a timer which tells when a certain object or enemy spawns. Spells have very often cooldowns a timer which tells for how long does the player have to wait until they can activate the spell again. Bomberman bomb explosion Duration Timers have duration in seconds at which the timer has to trigger an event. Cycles Timers can repeat them selves or they can be a one time event. They can be specified by the number of cycles. Events The event which has to be triggered when the timer ends. Implementation Duration in seconds Coroutine which waits for duration before it executes event. Event, trigger an even when the timer ends. Timer","title":"Timers"},{"location":"game_dev/building_blocks/timers.html#timers","text":"Timers are essential blocks for timing certain events. Certain portions of gameplay can be restricted by a timer. Super Mario Bros has a level timer by which the player has to finish the level, otherwise he dies. Super Smash Bros has a match timer which limits the duration of a match during which players have to defeat one another. Timers play an essential role in many aspects of game play. Spawner has a timer which tells when a certain object or enemy spawns. Spells have very often cooldowns a timer which tells for how long does the player have to wait until they can activate the spell again. Bomberman bomb explosion","title":"Timers"},{"location":"game_dev/building_blocks/timers.html#duration","text":"Timers have duration in seconds at which the timer has to trigger an event.","title":"Duration"},{"location":"game_dev/building_blocks/timers.html#cycles","text":"Timers can repeat them selves or they can be a one time event. They can be specified by the number of cycles.","title":"Cycles"},{"location":"game_dev/building_blocks/timers.html#events","text":"The event which has to be triggered when the timer ends.","title":"Events"},{"location":"game_dev/building_blocks/timers.html#implementation","text":"Duration in seconds Coroutine which waits for duration before it executes event. Event, trigger an even when the timer ends.","title":"Implementation"},{"location":"game_dev/building_blocks/timers.html#timer","text":"","title":"Timer"},{"location":"game_dev/building_blocks/triggers.html","text":"Triggers Triggers are very similar to colliders but instead of being a barrier which cant be walked in to, it is a detector which main purpose is to be walked in to or detect that something has entered it. It can detect players, npcs, objects. Triggers are the most primitive game element we can introduce in a game. From a simple switch which opens some door, to a very complicated puzzles or systems which can very easily keep us occupied for several hours. Minecraft trigger trap What makes a trigger detect stuff? Grid On a grid based game, we can identify a trigger with a specific trigger tile. If we can identify which tile on the grid is for walking and which is not, we can also create another class of a tile which is meant for triggering. Colliders Primitive shapes which describe a specific volume can be also used as triggers in most physics engines. We usually have to use some kind of flag on the collider to make it act as a trigger, otherwise it would be behaving as a wall. Events Every trigger triggers an event when it detects something. An event is simply a link to a specific function. That function is called when we activate the trigger. Implementation Our trigger script needs to inherit from MonoBehaviour in order so it can receive messages about triggers. MonoBehaviour class implements three trigger related messages. - OnTriggerEnter - OnTriggerStay - OnTriggerExit We will use only OnTriggerEnter and OnTriggerExit for now. Naive trigger The code above will do most of its job but it is far from perfect. It is made as simple as possible but does not cover many different cases. One of the case is that if two objects enter and then single object exits we will get this sequence. OnTriggerEnter Collider1 // Enable wall OnTriggerEnter Collider2 // Enable wall OnTriggerExit Collider1 // Disable wall If our events would just enable and disable a wall for example, The wall would disable early even that an collider is still inside the trigger, that is because we got an OnTriggerExit early because an collider has exited the trigger. One of the solutions would be to make sure that only a single collider can enter and exit the trigger. But this would be very hard to achieve in the scene. The other solution is to remember which colliders have entered and which colliders have left the trigger. Counter trigger This solution triggers enter only when at least single object enters the trigger and triggers exit only when all objects leave the trigger. This trigger is pretty robust towards multiple object detection.","title":"Triggers"},{"location":"game_dev/building_blocks/triggers.html#triggers","text":"Triggers are very similar to colliders but instead of being a barrier which cant be walked in to, it is a detector which main purpose is to be walked in to or detect that something has entered it. It can detect players, npcs, objects. Triggers are the most primitive game element we can introduce in a game. From a simple switch which opens some door, to a very complicated puzzles or systems which can very easily keep us occupied for several hours. Minecraft trigger trap What makes a trigger detect stuff?","title":"Triggers"},{"location":"game_dev/building_blocks/triggers.html#grid","text":"On a grid based game, we can identify a trigger with a specific trigger tile. If we can identify which tile on the grid is for walking and which is not, we can also create another class of a tile which is meant for triggering.","title":"Grid"},{"location":"game_dev/building_blocks/triggers.html#colliders","text":"Primitive shapes which describe a specific volume can be also used as triggers in most physics engines. We usually have to use some kind of flag on the collider to make it act as a trigger, otherwise it would be behaving as a wall.","title":"Colliders"},{"location":"game_dev/building_blocks/triggers.html#events","text":"Every trigger triggers an event when it detects something. An event is simply a link to a specific function. That function is called when we activate the trigger.","title":"Events"},{"location":"game_dev/building_blocks/triggers.html#implementation","text":"Our trigger script needs to inherit from MonoBehaviour in order so it can receive messages about triggers. MonoBehaviour class implements three trigger related messages. - OnTriggerEnter - OnTriggerStay - OnTriggerExit We will use only OnTriggerEnter and OnTriggerExit for now.","title":"Implementation"},{"location":"game_dev/building_blocks/triggers.html#naive-trigger","text":"The code above will do most of its job but it is far from perfect. It is made as simple as possible but does not cover many different cases. One of the case is that if two objects enter and then single object exits we will get this sequence. OnTriggerEnter Collider1 // Enable wall OnTriggerEnter Collider2 // Enable wall OnTriggerExit Collider1 // Disable wall If our events would just enable and disable a wall for example, The wall would disable early even that an collider is still inside the trigger, that is because we got an OnTriggerExit early because an collider has exited the trigger. One of the solutions would be to make sure that only a single collider can enter and exit the trigger. But this would be very hard to achieve in the scene. The other solution is to remember which colliders have entered and which colliders have left the trigger.","title":"Naive trigger"},{"location":"game_dev/building_blocks/triggers.html#counter-trigger","text":"This solution triggers enter only when at least single object enters the trigger and triggers exit only when all objects leave the trigger. This trigger is pretty robust towards multiple object detection.","title":"Counter trigger"},{"location":"game_dev/theory/game_engines.html","text":"Game engines The purpose of game engine is to make game developers life simpler. It is a collection of tools which increase productivity. In the past the only game engine available was the one you had to write your self. Today we have many game engines available. While there are many debates about which engine is the best, it always depends on the task. Some games need great terrain editor and hyper realistic visuals. Some games need custom rendering pipeline, custom asset pipelines and don't have the time to build a custom engine Some games want a simple engine and prefer open source. Unreal Engine Unity3D Godot There is not a perfect engine for every task. So having multiple engines is always great for developers. However, every engine is made of specific parts which have similar function across all engines. Those parts are: Asset management: importing 3D models, materials, textures, sprites, animations, sounds, movie clips. Physics: colliders, collision detection, rigid bodies, triggers, joints, cloth, ragdolls. Scene/Level: scene graph for placing 3D models, cameras, lights, sounds, sprites, scripts, colliders. Terrain: tools for creating rich virtual worlds, object scattering, terrain painting. Scripting: node based or textual. Animation: importing animations, skeletal animation, animation playback, animation state machines. Rendering: render pipeline, cameras, lights, materials, meshes, shaders. Sound: sound playback, sound mixer, sound effects. User Interface: layout engine, sprite renderer, text engine, event system. Input system: keyboard, game-pad, vr-ar controllers, midi controllers. AI: path-finding, state machines, decision trees. Multiplayer: matchmaking, server-client. Asset store: gamedev premade assets and projects. Build/Deployment: Windows, Mac, Play Station, Xbox, Nintendo Switch, iOS, Android, Meta Quest. The decision of which engine to choose usually depends on the fidelity of those individual parts. There are also custom engines made by AAA game developers. Rockstar: RAGE Electronic Arts: Frostbite Ubisoft: Anvil, Disrupt, Snowdrop, Lead, Dunia Crytek: CryEngine Konami: Fox Engine CD Projekt: Red engine list of engines","title":"Game engines"},{"location":"game_dev/theory/game_engines.html#game-engines","text":"The purpose of game engine is to make game developers life simpler. It is a collection of tools which increase productivity. In the past the only game engine available was the one you had to write your self. Today we have many game engines available. While there are many debates about which engine is the best, it always depends on the task. Some games need great terrain editor and hyper realistic visuals. Some games need custom rendering pipeline, custom asset pipelines and don't have the time to build a custom engine Some games want a simple engine and prefer open source. Unreal Engine Unity3D Godot There is not a perfect engine for every task. So having multiple engines is always great for developers. However, every engine is made of specific parts which have similar function across all engines. Those parts are: Asset management: importing 3D models, materials, textures, sprites, animations, sounds, movie clips. Physics: colliders, collision detection, rigid bodies, triggers, joints, cloth, ragdolls. Scene/Level: scene graph for placing 3D models, cameras, lights, sounds, sprites, scripts, colliders. Terrain: tools for creating rich virtual worlds, object scattering, terrain painting. Scripting: node based or textual. Animation: importing animations, skeletal animation, animation playback, animation state machines. Rendering: render pipeline, cameras, lights, materials, meshes, shaders. Sound: sound playback, sound mixer, sound effects. User Interface: layout engine, sprite renderer, text engine, event system. Input system: keyboard, game-pad, vr-ar controllers, midi controllers. AI: path-finding, state machines, decision trees. Multiplayer: matchmaking, server-client. Asset store: gamedev premade assets and projects. Build/Deployment: Windows, Mac, Play Station, Xbox, Nintendo Switch, iOS, Android, Meta Quest. The decision of which engine to choose usually depends on the fidelity of those individual parts. There are also custom engines made by AAA game developers. Rockstar: RAGE Electronic Arts: Frostbite Ubisoft: Anvil, Disrupt, Snowdrop, Lead, Dunia Crytek: CryEngine Konami: Fox Engine CD Projekt: Red engine list of engines","title":"Game engines"},{"location":"game_dev/theory/physics.html","text":"Physics The purpose of a physics library is to make interactions with the game world simpler. Every physics library does essentially the same thing, just in a different way resulting in different performance and stability. The main features of physics engines are: Colliders Barriers which prevent the player from freely moving around. Primitive colliders Primitive geometrical shapes represented by a simple math equation. They are considered water tight and represent a physical volume inside the world. If rigid body tries to penetrate a primitive collider it will be pushed outside of the collider volume. Primitives are cheap to calculate. When combined primitive shapes can recreate any complex shape. Box sphere capsule composite colliders Composite shapes are usually made of triangles. They are very convenient as they are automatically generated from our 3D meshes, however whenever there is a single error in our mesh, vertices, edges not connected or a wrong face orientation the collision can be easily penetrable. Triangles do not form water tight solids, therefore it is possible to penetrate them because they represent just a thin wall with single direction of penetration. They are very often the cause of holes inside games. Convex shapes Concave shapes Collision interactions Colliders are static barriers and we should not move them during gameplay. Rigid bodies are meant to be moved in the game and interact with colliders. Ridid bodies have to use layer mask in order to tell which colliders they should interact with. Collision Matrix Unity uses a layer based collision detection That means, all rigid bodies and colliders need specify its layer and the collision matrix explains, which layers interact with which layers. Collider detection We often want to detect if a player has hit an enemy. In that case we want to cast a ray in to the game world and detect if the ray intersects with any enemy or a wall. - ray casting When our projectile is larger than a beam of laser or a small bullet we want the projectile to deflect or stop even when its side just touches a wall. sphere casting capsule casting box casting Sometimes we want to just find all colliders overlapping a certain area. - primitive shape overlap When a player hits an enemy we often want to calculate the amount of damage dealt, we can use contact point detection for that. - Contact point detection Triggers When a player walks in to certain area we want to play sound or cinematic cutscene for that we use triggers. Rigid bodies Non-kinematic rigidbodies are for simulating objects which are being pushed around by other colliders, rigidbodies or forces like gravity or wind. They are driven only by the physics engine. Kinematic rigidbodies are for animation driven collisions. They are not moving by the physics engine but by the animation. This very often leads to issues as the wall it self cannot be stopped by the physics engine, but everything else is being affected by the wall. This can often lead to unwanted collisions and object penetration. Unity Physics API List of popular physics engine libraries Nvidia PhysX Bullet Box2D Havok Unreal engine has custom physics library Chaos","title":"Physics"},{"location":"game_dev/theory/physics.html#physics","text":"The purpose of a physics library is to make interactions with the game world simpler. Every physics library does essentially the same thing, just in a different way resulting in different performance and stability. The main features of physics engines are:","title":"Physics"},{"location":"game_dev/theory/physics.html#colliders","text":"Barriers which prevent the player from freely moving around.","title":"Colliders"},{"location":"game_dev/theory/physics.html#primitive-colliders","text":"Primitive geometrical shapes represented by a simple math equation. They are considered water tight and represent a physical volume inside the world. If rigid body tries to penetrate a primitive collider it will be pushed outside of the collider volume. Primitives are cheap to calculate. When combined primitive shapes can recreate any complex shape. Box sphere capsule","title":"Primitive colliders"},{"location":"game_dev/theory/physics.html#composite-colliders","text":"Composite shapes are usually made of triangles. They are very convenient as they are automatically generated from our 3D meshes, however whenever there is a single error in our mesh, vertices, edges not connected or a wrong face orientation the collision can be easily penetrable. Triangles do not form water tight solids, therefore it is possible to penetrate them because they represent just a thin wall with single direction of penetration. They are very often the cause of holes inside games. Convex shapes Concave shapes","title":"composite colliders"},{"location":"game_dev/theory/physics.html#collision-interactions","text":"Colliders are static barriers and we should not move them during gameplay. Rigid bodies are meant to be moved in the game and interact with colliders. Ridid bodies have to use layer mask in order to tell which colliders they should interact with.","title":"Collision interactions"},{"location":"game_dev/theory/physics.html#collision-matrix","text":"Unity uses a layer based collision detection That means, all rigid bodies and colliders need specify its layer and the collision matrix explains, which layers interact with which layers.","title":"Collision Matrix"},{"location":"game_dev/theory/physics.html#collider-detection","text":"We often want to detect if a player has hit an enemy. In that case we want to cast a ray in to the game world and detect if the ray intersects with any enemy or a wall. - ray casting When our projectile is larger than a beam of laser or a small bullet we want the projectile to deflect or stop even when its side just touches a wall. sphere casting capsule casting box casting Sometimes we want to just find all colliders overlapping a certain area. - primitive shape overlap When a player hits an enemy we often want to calculate the amount of damage dealt, we can use contact point detection for that. - Contact point detection","title":"Collider detection"},{"location":"game_dev/theory/physics.html#triggers","text":"When a player walks in to certain area we want to play sound or cinematic cutscene for that we use triggers.","title":"Triggers"},{"location":"game_dev/theory/physics.html#rigid-bodies","text":"Non-kinematic rigidbodies are for simulating objects which are being pushed around by other colliders, rigidbodies or forces like gravity or wind. They are driven only by the physics engine. Kinematic rigidbodies are for animation driven collisions. They are not moving by the physics engine but by the animation. This very often leads to issues as the wall it self cannot be stopped by the physics engine, but everything else is being affected by the wall. This can often lead to unwanted collisions and object penetration. Unity Physics API","title":"Rigid bodies"},{"location":"game_dev/theory/physics.html#list-of-popular-physics-engine-libraries","text":"Nvidia PhysX Bullet Box2D Havok Unreal engine has custom physics library Chaos","title":"List of popular physics engine libraries"},{"location":"game_dev/theory/rendering.html","text":"Rendering Games have to somehow give feedback to the player. The very early games used only text because the hardware did not had the performance to render anything more complicated. When the computer and gaming consoles obtained a dedicated graphics chip, games became visually more sophisticated and the visuals of the game became one of the key aspect in promoting the game. The process of rendering can be broken in several parts. Camera -> Scene -> Meshes -> Materials -> Lights -> Screen Camera Game camera is very similar to a physical or smartphone camera. It mimics a lens which has a focal length which defines the field of view. Every camera has a sensor which detects light, in games the sensor is our screen. The screen therefore the sensor defines our image aspect ratio. The main difference between game camera and physical camera is that game cameras have a primitive called frustum. Frustum is defined by near and far clip planes and the field of view of the camera. The purpose of the camera frustum is to filter only the meshes from the scene which should be visible and reject the one which are not visible. This process is called frustum culling. This is the main optimization step of every game engine. Scene The camera traverses the scene and looks for every object which should be rendered, as said before the objects are being filtered using the camera frustum. Some game engines also use occlusion culling, which is basically a method which rejects geometry which would be not visible in the final image due to occluding geometry. Meshes Each mesh is made of vertices and triangles. Those triangles are being combined based on the material. If multiple meshes have same material, they can be combined in to a single bigger mesh. This is called batching and its also a very important optimization step. Materials When meshes are batched to gether based on its materials they are also split based on its transparency. Opaque meshes are rendered before transparent meshes and the main reason is again optimization. We first need to sort the opaque meshes based on the camera distance. We render the nearest meshes to the camera first and the furthest meshes as last. In order that we never render pixels which are invisible we use a special texture called depth texture. Everytime a pixel is drawn on the screen it first looks in the depth buffer to check if a pixel with closer depth value has been already drawn and if it was, we simply don't render that pixel. Transparent meshes have to be also sorted based on the distance from the camera but in opposite direction. The furthest meshes are drawn first and then the closest meshes are drawn last. This technique is called the painters algorithm and it mimics the way how painters draw a picture. Lights Our objects usually should respond to lighting, so we need to collect all lights from the scene and make sure that each light is contributing to the final picture. There are two most common ways of rendering lights in games. Forward rendering. It renders the mesh as many times as there are light affecting it. The mesh is additively added to the final picture. The main benefit of forward rendering is simplicity when not many lights is being rendered and also great anti-aliasing of edges. Deferred rendering. It renders each opaque mesh usually 4 or more times in to separate textures. Usually color texture, depth texture, normals texture and PBR texture. When we then combine those texture, we can very easily render those lights as an image filter / post effect. Deferred rendering is great for rendering large amount of lights, but it is very hard to keep edges smooth. Anti-aliasing in deferred rendering is usually complex and produces a blurry image with jaggy edges. Transparent meshes have to use forward rendering. Screen The last step is to present the final image to the screen. During this process we also apply many post effects like color correction to create a more filmic look, but also bloom effects and lens flares to simulate physical camera lens effects. If the game uses deferred rendering it also has to smooth out jaggy edges. This effect is called anti-aliasing. There are many different ways of achieving smooth edges, but none of them is perfect.","title":"Rendering"},{"location":"game_dev/theory/rendering.html#rendering","text":"Games have to somehow give feedback to the player. The very early games used only text because the hardware did not had the performance to render anything more complicated. When the computer and gaming consoles obtained a dedicated graphics chip, games became visually more sophisticated and the visuals of the game became one of the key aspect in promoting the game. The process of rendering can be broken in several parts. Camera -> Scene -> Meshes -> Materials -> Lights -> Screen","title":"Rendering"},{"location":"game_dev/theory/rendering.html#camera","text":"Game camera is very similar to a physical or smartphone camera. It mimics a lens which has a focal length which defines the field of view. Every camera has a sensor which detects light, in games the sensor is our screen. The screen therefore the sensor defines our image aspect ratio. The main difference between game camera and physical camera is that game cameras have a primitive called frustum. Frustum is defined by near and far clip planes and the field of view of the camera. The purpose of the camera frustum is to filter only the meshes from the scene which should be visible and reject the one which are not visible. This process is called frustum culling. This is the main optimization step of every game engine.","title":"Camera"},{"location":"game_dev/theory/rendering.html#scene","text":"The camera traverses the scene and looks for every object which should be rendered, as said before the objects are being filtered using the camera frustum. Some game engines also use occlusion culling, which is basically a method which rejects geometry which would be not visible in the final image due to occluding geometry.","title":"Scene"},{"location":"game_dev/theory/rendering.html#meshes","text":"Each mesh is made of vertices and triangles. Those triangles are being combined based on the material. If multiple meshes have same material, they can be combined in to a single bigger mesh. This is called batching and its also a very important optimization step.","title":"Meshes"},{"location":"game_dev/theory/rendering.html#materials","text":"When meshes are batched to gether based on its materials they are also split based on its transparency. Opaque meshes are rendered before transparent meshes and the main reason is again optimization. We first need to sort the opaque meshes based on the camera distance. We render the nearest meshes to the camera first and the furthest meshes as last. In order that we never render pixels which are invisible we use a special texture called depth texture. Everytime a pixel is drawn on the screen it first looks in the depth buffer to check if a pixel with closer depth value has been already drawn and if it was, we simply don't render that pixel. Transparent meshes have to be also sorted based on the distance from the camera but in opposite direction. The furthest meshes are drawn first and then the closest meshes are drawn last. This technique is called the painters algorithm and it mimics the way how painters draw a picture.","title":"Materials"},{"location":"game_dev/theory/rendering.html#lights","text":"Our objects usually should respond to lighting, so we need to collect all lights from the scene and make sure that each light is contributing to the final picture. There are two most common ways of rendering lights in games. Forward rendering. It renders the mesh as many times as there are light affecting it. The mesh is additively added to the final picture. The main benefit of forward rendering is simplicity when not many lights is being rendered and also great anti-aliasing of edges. Deferred rendering. It renders each opaque mesh usually 4 or more times in to separate textures. Usually color texture, depth texture, normals texture and PBR texture. When we then combine those texture, we can very easily render those lights as an image filter / post effect. Deferred rendering is great for rendering large amount of lights, but it is very hard to keep edges smooth. Anti-aliasing in deferred rendering is usually complex and produces a blurry image with jaggy edges. Transparent meshes have to use forward rendering.","title":"Lights"},{"location":"game_dev/theory/rendering.html#screen","text":"The last step is to present the final image to the screen. During this process we also apply many post effects like color correction to create a more filmic look, but also bloom effects and lens flares to simulate physical camera lens effects. If the game uses deferred rendering it also has to smooth out jaggy edges. This effect is called anti-aliasing. There are many different ways of achieving smooth edges, but none of them is perfect.","title":"Screen"},{"location":"game_dev/theory/time.html","text":"Time Games are considered one of the hardest discipline in computer science because they have to run in realtime. Realtime means that our game has to be responsive towards user input. If the game would take 1 second to respond to user input it would be still considered realtime application but from game perspective it could be unplayable. History Early games did not use time for controlling speed of the game but rather used the number of frames to update the game it self. This behavior had the benefit of the simplicity of the code but also one big downside and that was, whenever we put the game on a faster machine, the game as well ran faster. Which could increase the difficulty of the game, which was undesirable. Present Modern games do not use frames but rather keep track of time. We move objects in the game with certain velocity, that means certain distance per second. This has the benefit that no matter how fast the game runs, therefore how many FPS do we have, the game behaves almost the same. However, this makes the game development much more difficult because we need to be aware of this behavior, because if we don't understand what is happening we usually end up with undesired outcomes. FPS Frames per second We measure the speed of our game in number of rendered frames per second. The more frames we render per second the faster our game runs. Nvidia article about FPS in eSports Nvidia fps animation smoothness \\ One game, three devices Imagine a single game running on three different devices. mobile phone game runs at 30 FPS gaming console game runs at 60 FPS high-end pc. game runs at 90 FPS If our player would update its position 1 meter per frame mobile phone player would run 30 meters per second gaming console player would run 60 meters per second high-end pc player would run 90 meters per second. That would be highly undesirable because with high end pc the difficulty of the game increases 3x. What if we instead make sure that our player runs always at the same speed? mobile phone player has to run 1/30 meters per frame. gaming console player has to run 1/60 meters per frame. high-end pc player has to run 1/90 meters per frame. This way we can tell that the player always moves 1 meter per second on all devices. But there is a catch... All those devices never run exactly at the same framerate. They always fluctuate, due to: complexity of our game concurrency / multiple apps running simultaneously thermals / overheating low battery That means that our fraction cannot be a constant. Delta Time Instead we can calculate our fraction by measuring the duration of our previous frame. This fraction is called delta time. Unity delta time If we multiply our player speed with delta time each frame, our player would run at the same speed no matter what is the frame rate of our game on any device.","title":"Time"},{"location":"game_dev/theory/time.html#time","text":"Games are considered one of the hardest discipline in computer science because they have to run in realtime. Realtime means that our game has to be responsive towards user input. If the game would take 1 second to respond to user input it would be still considered realtime application but from game perspective it could be unplayable.","title":"Time"},{"location":"game_dev/theory/time.html#history","text":"Early games did not use time for controlling speed of the game but rather used the number of frames to update the game it self. This behavior had the benefit of the simplicity of the code but also one big downside and that was, whenever we put the game on a faster machine, the game as well ran faster. Which could increase the difficulty of the game, which was undesirable.","title":"History"},{"location":"game_dev/theory/time.html#present","text":"Modern games do not use frames but rather keep track of time. We move objects in the game with certain velocity, that means certain distance per second. This has the benefit that no matter how fast the game runs, therefore how many FPS do we have, the game behaves almost the same. However, this makes the game development much more difficult because we need to be aware of this behavior, because if we don't understand what is happening we usually end up with undesired outcomes.","title":"Present"},{"location":"game_dev/theory/time.html#fps","text":"Frames per second We measure the speed of our game in number of rendered frames per second. The more frames we render per second the faster our game runs. Nvidia article about FPS in eSports Nvidia fps animation smoothness \\","title":"FPS"},{"location":"game_dev/theory/time.html#one-game-three-devices","text":"Imagine a single game running on three different devices. mobile phone game runs at 30 FPS gaming console game runs at 60 FPS high-end pc. game runs at 90 FPS If our player would update its position 1 meter per frame mobile phone player would run 30 meters per second gaming console player would run 60 meters per second high-end pc player would run 90 meters per second. That would be highly undesirable because with high end pc the difficulty of the game increases 3x. What if we instead make sure that our player runs always at the same speed? mobile phone player has to run 1/30 meters per frame. gaming console player has to run 1/60 meters per frame. high-end pc player has to run 1/90 meters per frame. This way we can tell that the player always moves 1 meter per second on all devices. But there is a catch... All those devices never run exactly at the same framerate. They always fluctuate, due to: complexity of our game concurrency / multiple apps running simultaneously thermals / overheating low battery That means that our fraction cannot be a constant.","title":"One game, three devices"},{"location":"game_dev/theory/time.html#delta-time","text":"Instead we can calculate our fraction by measuring the duration of our previous frame. This fraction is called delta time. Unity delta time If we multiply our player speed with delta time each frame, our player would run at the same speed no matter what is the frame rate of our game on any device.","title":"Delta Time"},{"location":"game_dev/world/world.html","text":"World Our game would be pretty unplayable without a proper game world or environment. The purpose of our environment is to create boundaries where the player can or cant move. Mazes can get pretty uninteresting because how they look similar to each other. The reason why it is hard to orient your self in a maze is that mazes are missing important environmental queues. Worlds can be dissected in to several parts. Barriers Terrain Biomes Landmarks blocking tools level design","title":"World"},{"location":"game_dev/world/world.html#world","text":"Our game would be pretty unplayable without a proper game world or environment. The purpose of our environment is to create boundaries where the player can or cant move. Mazes can get pretty uninteresting because how they look similar to each other. The reason why it is hard to orient your self in a maze is that mazes are missing important environmental queues. Worlds can be dissected in to several parts. Barriers Terrain Biomes Landmarks blocking tools level design","title":"World"},{"location":"game_dev/world/world_barriers.html","text":"World World barriers Primary building block of most games are walls or barriers. They are the main game design element which gives the player a clear feedback about where they can or cant go. The most typical scenario would be a maze game. Maze games have very clear functionality without the need to use any script. The two openings of the maze clearly define start and finish. Maze animation \\ Colliders also serve us a walking platform. Many platforming games fine tune their colliders meticulously to achieve the perfect platform for jumping, running, wall running etc. Typical representations are: Grid Grid structure can very easily create a clear path which is walkable. It clearly presents it self to player and is very predictable. Because each block has the same size, it is very simple to design levels with grids. The main disadvantage of grids is a very blocky character of the whole level. The Legend of Zelda: Link's Awakening \\ Colliders Physics engines use colliders to define certain volumes which are walkable platforms or un walkable walls. They are expressed as primitive geometric objects with certain volume. Most common shapes are boxes, spheres, cylinders, capsules. The Last of Us \\","title":"Barriers"},{"location":"game_dev/world/world_barriers.html#world-barriers","text":"Primary building block of most games are walls or barriers. They are the main game design element which gives the player a clear feedback about where they can or cant go. The most typical scenario would be a maze game. Maze games have very clear functionality without the need to use any script. The two openings of the maze clearly define start and finish. Maze animation \\ Colliders also serve us a walking platform. Many platforming games fine tune their colliders meticulously to achieve the perfect platform for jumping, running, wall running etc. Typical representations are:","title":"World barriers"},{"location":"game_dev/world/world_barriers.html#grid","text":"Grid structure can very easily create a clear path which is walkable. It clearly presents it self to player and is very predictable. Because each block has the same size, it is very simple to design levels with grids. The main disadvantage of grids is a very blocky character of the whole level. The Legend of Zelda: Link's Awakening \\","title":"Grid"},{"location":"game_dev/world/world_barriers.html#colliders","text":"Physics engines use colliders to define certain volumes which are walkable platforms or un walkable walls. They are expressed as primitive geometric objects with certain volume. Most common shapes are boxes, spheres, cylinders, capsules. The Last of Us \\","title":"Colliders"},{"location":"game_dev/world/world_biomes.html","text":"World World biomes Many games which contain large worlds use biomes to differentiate individual places. Biomes drastically change which creatures and plants can live in such place. There is also clear indication of survival level, biomes which have less water are usually much more difficult to survive in. Famous games using biomes extensivelly. Minecraft Valheim World of Warcraft Red Dead Redemption 2 Terraria biomes Subnautica biomes biomes Terrestrial desert grassland forrest rainforest taiga tundra savanna wetlands mountains Marine coral reef open sea deep sea polar","title":"Biomes"},{"location":"game_dev/world/world_biomes.html#world-biomes","text":"Many games which contain large worlds use biomes to differentiate individual places. Biomes drastically change which creatures and plants can live in such place. There is also clear indication of survival level, biomes which have less water are usually much more difficult to survive in. Famous games using biomes extensivelly. Minecraft Valheim World of Warcraft Red Dead Redemption 2 Terraria biomes Subnautica biomes biomes Terrestrial desert grassland forrest rainforest taiga tundra savanna wetlands mountains Marine coral reef open sea deep sea polar","title":"World biomes"},{"location":"game_dev/world/world_design_blocking.html","text":"World World design blocking Most major games use blocking technique for designing its worlds. Blocking means that we just use primitive shapes like boxes, cylinders, spheres for creating the basic shape of our level. We never start modelling any assets in to our game until the level design blocking is done. Why? Imagine following scenario. - Level Designer creates first version of our world. - CGI artist creates props for the world. - Level Designer modifies our world and removes half of the props needed and adds more. - CGI artist is annoyed that his work has been scrapped. Continues modelling new props. - Level Designer modifies our world and removes some parts of the world. - CGI artist is frustrated as his work is clearly wasteful. - Level designer scraps the whole level because playtesters dont like the level. - CGI artist quits the job and moves to a different company. So how do CGI artists stay happy working at game companies? - Level Designer creates first version of our world and does a playtest. - Tester plays the level and brigs comments. - Level Designer integrates those comments in the world and creates additional changes. - Tester plays the level and finds bugs in collisions. - Level Designer fixes bugs in collisions and also adds new vistas. - Tester gets lost in the new vista and reports it. - Level Designer simplifies the vista and makes an update. - Tester cant find any issues with the level and plays the game more then he should. - Level is considered finished and is now handled to CGI artist to create assets for the level. The Last Of Us Team Fortress 2 Uncharted","title":"Blocking"},{"location":"game_dev/world/world_design_blocking.html#world-design-blocking","text":"Most major games use blocking technique for designing its worlds. Blocking means that we just use primitive shapes like boxes, cylinders, spheres for creating the basic shape of our level. We never start modelling any assets in to our game until the level design blocking is done. Why? Imagine following scenario. - Level Designer creates first version of our world. - CGI artist creates props for the world. - Level Designer modifies our world and removes half of the props needed and adds more. - CGI artist is annoyed that his work has been scrapped. Continues modelling new props. - Level Designer modifies our world and removes some parts of the world. - CGI artist is frustrated as his work is clearly wasteful. - Level designer scraps the whole level because playtesters dont like the level. - CGI artist quits the job and moves to a different company. So how do CGI artists stay happy working at game companies? - Level Designer creates first version of our world and does a playtest. - Tester plays the level and brigs comments. - Level Designer integrates those comments in the world and creates additional changes. - Tester plays the level and finds bugs in collisions. - Level Designer fixes bugs in collisions and also adds new vistas. - Tester gets lost in the new vista and reports it. - Level Designer simplifies the vista and makes an update. - Tester cant find any issues with the level and plays the game more then he should. - Level is considered finished and is now handled to CGI artist to create assets for the level. The Last Of Us Team Fortress 2 Uncharted","title":"World design blocking"},{"location":"game_dev/world/world_design_tools.html","text":"World World design For designing our worlds we can use following tools: Unity Terrain editor Unity Terrain Docs For creating our base terrain. Valleys and Hills Scattering tools for adding trees, bushes, houses. Trees Unity Probuilder Unity Probuilder Docs It is polygonal modelling tool directly in Unity. We can also use Blender and keep the source files in the Unity project as unity can easily work with them directly. Arch Stairs Door Blender Blender Blender can be used instead of probuilder, but the designer has to be aware of the needs of the game engine. If we would just create a wonderfull world inside blender and import it into Unity it would probably look nothing like it should in Unity and it would probably not even run smoothly. The game might be stuttering as blender does not understand the optimizations needed for the environment to be playable inside Unity. Therefore we use Blender mostly for modelling props.","title":"Tools"},{"location":"game_dev/world/world_design_tools.html#world-design","text":"For designing our worlds we can use following tools:","title":"World design"},{"location":"game_dev/world/world_design_tools.html#unity-terrain-editor","text":"Unity Terrain Docs For creating our base terrain. Valleys and Hills Scattering tools for adding trees, bushes, houses. Trees","title":"Unity Terrain editor"},{"location":"game_dev/world/world_design_tools.html#unity-probuilder","text":"Unity Probuilder Docs It is polygonal modelling tool directly in Unity. We can also use Blender and keep the source files in the Unity project as unity can easily work with them directly. Arch Stairs Door","title":"Unity Probuilder"},{"location":"game_dev/world/world_design_tools.html#blender","text":"Blender Blender can be used instead of probuilder, but the designer has to be aware of the needs of the game engine. If we would just create a wonderfull world inside blender and import it into Unity it would probably look nothing like it should in Unity and it would probably not even run smoothly. The game might be stuttering as blender does not understand the optimizations needed for the environment to be playable inside Unity. Therefore we use Blender mostly for modelling props.","title":"Blender"},{"location":"game_dev/world/world_landmarks.html","text":"World World landmarks Our environment is made of terrain but very often we need to focus the attention to a very specific place. We want those places to be memorable. Those memorable places can be called landmarks. Bioshock Infinite Monument Red dead redemption 2 Brandywine Drop Valheim Island Minecraft fireplace World of Warcraft mountain Legend of Zelda Great deku tree Shadow Of Tomb Rider Cave Nature vistas waterfalls water surface \"ponds, lakes\" hills mountains unique trees caves islands Urban fire places crossroads parks bridges factories mines statues monuments","title":"Landmarks"},{"location":"game_dev/world/world_landmarks.html#world-landmarks","text":"Our environment is made of terrain but very often we need to focus the attention to a very specific place. We want those places to be memorable. Those memorable places can be called landmarks. Bioshock Infinite Monument Red dead redemption 2 Brandywine Drop Valheim Island Minecraft fireplace World of Warcraft mountain Legend of Zelda Great deku tree Shadow Of Tomb Rider Cave Nature vistas waterfalls water surface \"ponds, lakes\" hills mountains unique trees caves islands Urban fire places crossroads parks bridges factories mines statues monuments","title":"World landmarks"},{"location":"game_dev/world/world_level_design.html","text":"World Level design Instead of dedicating a whole section about level design, I made this list of useful links about level design. Unreal engine level design fundamentals, text GDC Level Design Playlist, video Book about level design, text Reddit about level design, forum","title":"Level design"},{"location":"game_dev/world/world_level_design.html#level-design","text":"Instead of dedicating a whole section about level design, I made this list of useful links about level design. Unreal engine level design fundamentals, text GDC Level Design Playlist, video Book about level design, text Reddit about level design, forum","title":"Level design"},{"location":"game_dev/world/world_terrain.html","text":"World World Terrain World terrain creates natural paths and barriers which feels almost invisible. They are not distracting, they don't appear like a threating sign \"Do not walk!\" We respect those boundaries naturally from personal experience. Red Dead Redemption 2 river Last Of Us lake Assassin's Creed Black Flag sea Firewatch trail The Witness bridge Grand Theft Auto 5 city Minecraft shelter Kingdom Come Deliverence castle water streams rivers ponds lakes seas paths trails roads crossroads dead ends formations hills rocks mountains cliffs caves urban shelters cabins willages castles cities centre downtown uptown mines factories harbours parks","title":"Terrain"},{"location":"game_dev/world/world_terrain.html#world-terrain","text":"World terrain creates natural paths and barriers which feels almost invisible. They are not distracting, they don't appear like a threating sign \"Do not walk!\" We respect those boundaries naturally from personal experience. Red Dead Redemption 2 river Last Of Us lake Assassin's Creed Black Flag sea Firewatch trail The Witness bridge Grand Theft Auto 5 city Minecraft shelter Kingdom Come Deliverence castle water streams rivers ponds lakes seas paths trails roads crossroads dead ends formations hills rocks mountains cliffs caves urban shelters cabins willages castles cities centre downtown uptown mines factories harbours parks","title":"World Terrain"},{"location":"installation/unity_interactive_documentation.html","text":"Interactive documentation how to enable interactive documentation open window Window/Game dev for beginners Opening the window creates a connection between unity and the documentation. When the window closes the connection is also closed. The window logs all communication between unity and the documentation.","title":"Interactive documentation"},{"location":"installation/unity_interactive_documentation.html#interactive-documentation","text":"","title":"Interactive documentation"},{"location":"installation/unity_interactive_documentation.html#how-to-enable-interactive-documentation","text":"open window Window/Game dev for beginners Opening the window creates a connection between unity and the documentation. When the window closes the connection is also closed. The window logs all communication between unity and the documentation.","title":"how to enable interactive documentation"},{"location":"installation/unity_upm_installation.html","text":"Prerequisites Install the Git client (minimum version 2.14.0) on your computer. Install the Git LFS client on your computer. Procedure Open Package Manager from Window/Package Manager. Open the add menu in the Package Manager\u2019s toolbar. The options for adding packages appear. Select Add package from git URL from the add menu. Fill the text box with URL: https://github.com/jaroslavstehlik/GameDevForBeginners.git Hit OK. Prepare project Edit layers Open layer presets Apply layer preset Open physics settings from Edit/Project Settings Open physics presets Apply physics preset You are now all set!","title":"Unity package installation"},{"location":"installation/unity_upm_installation.html#prerequisites","text":"Install the Git client (minimum version 2.14.0) on your computer. Install the Git LFS client on your computer.","title":"Prerequisites"},{"location":"installation/unity_upm_installation.html#procedure","text":"Open Package Manager from Window/Package Manager. Open the add menu in the Package Manager\u2019s toolbar. The options for adding packages appear. Select Add package from git URL from the add menu. Fill the text box with URL: https://github.com/jaroslavstehlik/GameDevForBeginners.git Hit OK.","title":"Procedure"},{"location":"installation/unity_upm_installation.html#prepare-project","text":"Edit layers Open layer presets Apply layer preset Open physics settings from Edit/Project Settings Open physics presets Apply physics preset You are now all set!","title":"Prepare project"}]}